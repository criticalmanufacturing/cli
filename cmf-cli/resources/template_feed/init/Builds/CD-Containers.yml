# CM DS Continuous Deployment Containers Pipeline
pool:
  name: <%= $CLI_PARAM_AgentPool %>
//#if (agentType == "Cloud")
  vmImage: 'ubuntu-latest'
//#endif

# A pipeline with no CI trigger
trigger: none

# A pipeline with no PR trigger
pr: none

# Pipeline tiggered by CI-Publish
resources:
  pipelines:
  - pipeline: CIPublish
    source: CI-Builds/CI-Publish
    trigger: true

variables:
<<<<<<< Updated upstream
 - group: Docker Variables
 - template: ../EnvironmentConfigs/GlobalVariables.yml  # Template reference to global variables
 - template: ../EnvironmentConfigs/${{ parameters.Environment }}.yml  # Template reference to environment variables
=======
- group: Authentication Variables
- template: .vars/global.yml # Template reference to global variables
- template: .vars/${{ parameters.Environment }}.yml # Template reference to environment related variables
- name: RestoreIdentifier
  value: ORIGINAL
>>>>>>> Stashed changes

# Setted in runtime
parameters:
- name: Environment
  displayName: Environment name
  type: string
  default: <%= $CLI_PARAM_EnvironmentName %>
  values:
    - <%= $CLI_PARAM_EnvironmentName %>
# Stages to Run
- name: executeAllStages
  displayName: Execute all Stages
  type: boolean
  default: true
- name: PrepareEnvironment
  displayName: Prepare Environment
  type: boolean
  default: false
- name: Installation
  displayName: Installation
  type: boolean
  default: false
- name: RestorePoint
  displayName: Create Restore Point
  type: boolean
  default: false
- name: RunTestMasterData
  displayName: Run Test MasterData
  type: boolean
  default: false
- name: DailyBackup
  displayName: Daily Backup
  type: boolean
  default: false
- name: RunTests
  displayName: Run Tests
  type: boolean
  default: false
- name: ApprovalAndRetain
  displayName: Approval and Retain Pipeline
  type: boolean
  default: false
- name: SetNewRestorePoint
  displayName: Set New Restore Point
  type: boolean
  default: false

name: Release-$(Build.BuildId)
stages:
- stage: Artifacts
  displayName: Artifacts
  jobs:
  - job: Artifacts_Job
    displayName: Download
    workspace:
      clean: all
    steps:
    - checkout: none

    # Download CD Artifacts
    - template: .tasks/download-cd-artifacts.yml

    # Install cmf-pipeline
    - template: .tasks/install-cmf-pipeline.yml

    # Copy External Package Dependencies
    - pwsh: $(Agent.TempDirectory)/node_modules/@criticalmanufacturing/cmf-pipeline/dist/win-x64/cmf-pipeline copyDependencies $(CandidatePackages)/Configurations/dependencies.json $(CandidatePackages)/Package
      displayName: Copy External Package Dependencies

<<<<<<< Updated upstream
        - task: SqlDacpacDeploymentOnMachineGroup@0
          displayName: "Drop ONLINE database"
          inputs:
            TaskType: 'sqlInline'
            InlineSql: |
              IF EXISTS (SELECT name from sys.databases WHERE (name = N'$(SYSTEM_NAME)'))
              BEGIN
                EXEC msdb.dbo.sp_delete_database_backuphistory @database_name = N'$(SYSTEM_NAME)'
                ALTER DATABASE [$(SYSTEM_NAME)] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
                DROP DATABASE IF EXISTS $(SYSTEM_NAME)
              END;
            ServerName: '$(DATABASE_ONLINE_MSSQL_ADDRESS)'
            DatabaseName: 'master'
            AuthScheme: 'sqlServerAuthentication'
            SqlUsername: '$(DATABASE_ONLINE_MSSQL_USERNAME)'
            SqlPassword: '$(DATABASE_ONLINE_MSSQL_PASSWORD)'

        - task: SqlDacpacDeploymentOnMachineGroup@0
          displayName: "Drop ODS database"
          inputs:
            TaskType: 'sqlInline'
            InlineSql: |
              IF EXISTS (SELECT name from sys.databases WHERE (name = N'$(SYSTEM_NAME)ODS'))
              BEGIN
                EXEC msdb.dbo.sp_delete_database_backuphistory @database_name = N'$(SYSTEM_NAME)ODS'
                ALTER DATABASE [$(SYSTEM_NAME)ODS] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
                DROP DATABASE IF EXISTS $(SYSTEM_NAME)ODS
              END;
            ServerName: '$(DATABASE_ODS_MSSQL_ADDRESS)'
            DatabaseName: 'master'
            AuthScheme: 'sqlServerAuthentication'
            SqlUsername: '$(DATABASE_ODS_MSSQL_USERNAME)'
            SqlPassword: '$(DATABASE_ODS_MSSQL_PASSWORD)'

        - task: SqlDacpacDeploymentOnMachineGroup@0
          displayName: "Drop DWH database"
          inputs:
            TaskType: 'sqlInline'
            InlineSql: |
              IF EXISTS (SELECT name from sys.databases WHERE (name = N'$(SYSTEM_NAME)DWH'))
              BEGIN
                EXEC msdb.dbo.sp_delete_database_backuphistory @database_name = N'$(SYSTEM_NAME)DWH'
                ALTER DATABASE [$(SYSTEM_NAME)DWH] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
                DROP DATABASE IF EXISTS $(SYSTEM_NAME)DWH
              END;
            ServerName: '$(DATABASE_DWH_MSSQL_ADDRESS)'
            DatabaseName: 'master'
            AuthScheme: 'sqlServerAuthentication'
            SqlUsername: '$(DATABASE_DWH_MSSQL_USERNAME)'
            SqlPassword: '$(DATABASE_DWH_MSSQL_PASSWORD)'

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "Installation"
    displayName: "Installation"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.Installation }}', true) ) )
    jobs:
      - job: "Installation"
        displayName: "Installation"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Clean deploy folder
        - task: DeleteFiles@1
          displayName: 'Clean deploy folder'
          inputs:
            SourceFolder: '${{ variables.CandidatePackages }}'
            Contents: '**'

        # Download Package Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Package Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Package'
            downloadPath: '${{ variables.CandidatePackages }}'

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        # Copy External Package Dependencies
        # use Node Tool
        - task: NodeTool@0
          displayName: 'Use Node ${{ variables.NodeVersion }}'
          inputs:
            versionSpec: ${{ variables.NodeVersion }}

        # Install cmf-pipeline
        - task: PowerShell@2
          displayName: 'Install cmf-pipeline@${{ variables.CmfPipelineVersion }}'
          inputs:
            pwsh: true
            failOnStderr: false
            workingDirectory: $(Agent.TempDirectory)
            targetType: inline
            script: |
              npm install --no-save @criticalmanufacturing/cmf-pipeline@${{ variables.CmfPipelineVersion }} --registry ${{ variables.CmfPipelineRepository }}

        - task: PowerShell@2
          displayName: "cmf-pipeline copyDependencies"
          inputs:
            targetType: 'inline'
            script: |
              $(Agent.TempDirectory)/node_modules/@criticalmanufacturing/cmf-pipeline/dist/win-x64/cmf-pipeline copyDependencies Configurations/dependencies.json ${{ variables.CandidatePackages }}/Package
            pwsh: true

        - task: replacetokens@4
          displayName: 'Replace tokens in parameters files'
          inputs:
            rootDirectory: 'Configurations'
            targetFiles: '**/*.json'
            keepToken: true
            tokenPrefix: '#{'
            tokenSuffix: '}#'

        - task: PowerShell@2
          displayName: "Get portal-sdk"
          inputs:
            pwsh: true
            failOnStderr: false
            workingDirectory: $(Agent.TempDirectory)
            targetType: inline
            script: |
              npm install --no-save @criticalmanufacturing/portal --registry ${{ variables.CmfCliRepository }}

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil -or ($_.Value.GetType().FullName -eq "System.Management.Automation.PSCustomObject"))) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }

        - task: PowerShell@2
          displayName: "Generate Environment Installation Parameters"
          inputs:
            targetType: 'inline'
            failOnStderr: true
            pwsh: true
            script: |
              $PackageId = "${{ variables.RootPackageIdToInstall }}"

              if($PackageId)
              {
                $PackageVersion = (Get-Item "${{ variables.CandidatePackages }}/Package/$PackageId*").BaseName -replace "$PackageId."
              }
              else
              {
                $CmfPackageJsonFile = Get-Item "./Configurations/cmfpackage.json"
                $CmfPackageJson = Get-Content -Raw -Path $CmfPackageJsonFile | ConvertFrom-Json
                $PackageId = $CmfPackageJson.'packageId'
                $PackageVersion = $CmfPackageJson.'version'
              }
              $PackageToInstall = "$PackageId@$PackageVersion"

              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
              $envConfig.ENV_MANAGER_BOOT_PACKAGE = $PackageToInstall

              Write-Output "Installing package $PackageToInstall"
              $envConfig | ConvertTo-Json -Depth 10 | set-content "$(Agent.TempDirectory)/install-package.json"

        # Installation with customization
        - task: PowerShell@2
          displayName: "Installation"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $packageSourceShare = "$(CandidatePackages)/Package"
              Copy-Item -Path $(DATABASE_NETWORK_SHARE)/approved/Cmf.FullBackup.*.zip -Destination $packageSourceShare -Force -Verbose
              if (Test-Path "Configurations/EnvironmentConfigs/devopscenter.qa.json" -PathType leaf)
              {
                Copy-Item -Path Configurations/EnvironmentConfigs/devopscenter.qa.json -Destination $env:AGENT_TEMPDIRECTORY/node_modules/@criticalmanufacturing/portal/bin/appsettings.json -Force
              }
              & $env:AGENT_TEMPDIRECTORY/node_modules/@criticalmanufacturing/portal/bin/cmf-portal.exe login --token $(CustomerPortalPAT) --verbose
              & $env:AGENT_TEMPDIRECTORY/node_modules/@criticalmanufacturing/portal/bin/cmf-portal.exe deploy `
                --name "${{ variables.CustomerEnvironmentName }}" `
                --customer-infrastructure-name "DS Integration Environments" `
                --parameters "$(Agent.TempDirectory)/install-package.json" `
                --license "${{ variables.LicenseName }}" `
                --site "${{ variables.SiteName }}" `
                --target "${{ variables.DeploymentTarget }}" `
                --package="${{ variables.DeploymentPackage }}" `
                --terminateOtherVersions --verbose

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "RestorePoint"
    displayName: "Restore Point"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.RestorePoint }}', true) ) )
    jobs:
      - job: "RestorePoint"
        displayName: "Restore Point"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        - task: replacetokens@4
          displayName: 'Replace tokens in parameters files'
          inputs:
            rootDirectory: 'Configurations'
            targetFiles: '**/*.json'
            keepToken: true
            tokenPrefix: '#{'
            tokenSuffix: '}#'

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil -or ($_.Value.GetType().FullName -eq "System.Management.Automation.PSCustomObject"))) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }

        - task: PowerShell@2
          displayName: "Generate backup parameters"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "$env:AGENT_TEMPDIRECTORY/backup_parameters.json"
              $json = @"
              {
              "Product.SystemName": "$(SYSTEM_NAME)",
              "Product.Database.BackupShare": "$('$(DATABASE_NETWORK_SHARE)' -replace '\\', '\\')",
              "Product.BackupDatabase.UseCompression": true,
              "Package[Product.Database.Online].Database.Server": "$('$(DATABASE_ONLINE_MSSQL_ADDRESS)' -replace '\\', '\\')",
              "Package[Product.Database.Online].Database.User": "$('$(DATABASE_ONLINE_MSSQL_USERNAME)' -replace '\\', '\\')",
              "Package[Product.Database.Online].Database.Password": "$('$(DATABASE_ONLINE_MSSQL_PASSWORD)' -replace '\\', '\\')",
              "Package[Product.Database.Ods].Database.Server": "$('$(DATABASE_ODS_MSSQL_ADDRESS)' -replace '\\', '\\')",
              "Package[Product.Database.Ods].Database.User": "$('$(DATABASE_ODS_MSSQL_USERNAME)' -replace '\\', '\\')",
              "Package[Product.Database.Ods].Database.Password": "$('$(DATABASE_ODS_MSSQL_PASSWORD)' -replace '\\', '\\')",
              "Package[Product.Database.Dwh].Database.Server": "$('$(DATABASE_DWH_MSSQL_ADDRESS)' -replace '\\', '\\')",
              "Package[Product.Database.Dwh].Database.User": "$('$(DATABASE_DWH_MSSQL_USERNAME)' -replace '\\', '\\')",
              "Package[Product.Database.Dwh].Database.Password": "$('$(DATABASE_DWH_MSSQL_PASSWORD)' -replace '\\', '\\')"
              }
              "@
              $json | set-content $file
              Write-Host $json

        - task: PowerShell@2
          displayName: "Full Backup"
          inputs:
            targetType: 'inline'
            script: |
              Remove-Item -Path $(DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Force -Verbose
              Remove-Item -Path $(DATABASE_NETWORK_SHARE)/*.bak -Force -Verbose
              Remove-Item -Path $(DATABASE_NETWORK_SHARE)/FullBackup -Force -Verbose -Recurse -ErrorAction Ignore
              New-Item -ItemType Directory -Path "$(DATABASE_NETWORK_SHARE)" -Name "FullBackup" -Force
              & tools\CmfDeploy.exe backup --parameters $env:AGENT_TEMPDIRECTORY/backup_parameters.json --packageSources .\DFPackages
              Move-Item -Path $(DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Destination $(DATABASE_NETWORK_SHARE)/FullBackup -Force
            pwsh: true
            workingDirectory: 'C:\tools\Cmf.Deployment.Framework'

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "RunTestMasterData"
    displayName: "Run Test Master Data"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.RunTestMasterData }}', true) ) )
    jobs:
      - job: "RunTestMasterData"
        displayName: "Run Test Master Data"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        # Download Tests Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Tests Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Tests'
            downloadPath: '${{ variables.CandidatePackages }}'
          continueOnError: true

        # Verify if Artifact exists - Tests.MasterData
        - task: PowerShell@2
          displayName: Verify if Artifact exists - Tests.MasterData
          inputs:
            targetType: inline
            script: |
                $testMasterDataFilter = "${{ variables.TestMasterDataFilter }}"
                if(!$testMasterDataFilter)
                {
                  $testMasterDataFilter = "*MasterData*"
                }
                $masterDataFiles = "${{ variables.CandidatePackages }}/Tests/$testMasterDataFilter.zip"
                Write-Host "##vso[task.setVariable variable=ArtifactExists;]false"

                if (Get-ChildItem -Path $masterDataFiles)
                {
                    Write-Host "##vso[task.setVariable variable=ArtifactExists;]true"
                }

        - task: replacetokens@4
          displayName: 'Replace tokens in parameters files'
          inputs:
            rootDirectory: 'Configurations'
            targetFiles: '**/*.json'
            keepToken: true
            tokenPrefix: '#{'
            tokenSuffix: '}#'

        - task: PowerShell@2
          displayName: "Get portal-sdk"
          inputs:
            pwsh: true
            failOnStderr: false
            workingDirectory: $(Agent.TempDirectory)
            targetType: inline
            script: |
              npm install --no-save @criticalmanufacturing/portal --registry ${{ variables.CmfCliRepository }}

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil -or ($_.Value.GetType().FullName -eq "System.Management.Automation.PSCustomObject"))) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }

        - task: PowerShell@2
          displayName: "MasterData Loading"
          inputs:
            targetType: 'inline'
            script: |
              $testMasterDataFilter = "${{ variables.TestMasterDataFilter }}"
              if(!$testMasterDataFilter)
              {
                $testMasterDataFilter = "*MasterData*"
              }
              $masterDataFiles = "${{ variables.CandidatePackages }}/Tests/$testMasterDataFilter.zip"

              Get-ChildItem $masterDataFiles | foreach {
                  $PackageId = [regex]::split($_.BaseName, ".[0-9]+.[0-9]+.[0-9]+")[0];
                  $PackageVersion = ($_.BaseName-replace "$PackageId." );

                  $PackageToInstall = $PackageId + '@' + $PackageVersion
                  $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.ENV_MANAGER_BOOT_PACKAGE = $PackageToInstall

                  Write-Output "Installing package $PackageId"
                  $envConfig | ConvertTo-Json -Depth 10 | set-content "$(Agent.TempDirectory)/install-package.json"

                  & $env:AGENT_TEMPDIRECTORY/node_modules/@criticalmanufacturing/portal/bin/cmf-portal.exe login --token $(CustomerPortalPAT) --verbose
                  & $env:AGENT_TEMPDIRECTORY/node_modules/@criticalmanufacturing/portal/bin/cmf-portal.exe deploy `
                    --name "${{ variables.CustomerEnvironmentName }}" `
                    --customer-infrastructure-name "DS Integration Environments" `
                    --parameters "$(Agent.TempDirectory)/install-package.json" `
                    --license "${{ variables.LicenseName }}" `
                    --site "${{ variables.SiteName }}" `
                    --target "${{ variables.DeploymentTarget }}" `
                    --package="${{ variables.DeploymentPackage }}" `
                    --terminateOtherVersions --verbose
              }
            pwsh: true
          condition: eq(variables['ArtifactExists'], true)

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "DailyBackup"
    displayName: "Daily Backup"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.DailyBackup }}', true) ) )
    jobs:
      - job: "DailyBackup"
        displayName: "Daily Backup"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        - task: replacetokens@4
          displayName: 'Replace tokens in parameters files'
          inputs:
            rootDirectory: 'Configurations'
            targetFiles: '**/*.json'
            keepToken: true
            tokenPrefix: '#{'
            tokenSuffix: '}#'

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil -or ($_.Value.GetType().FullName -eq "System.Management.Automation.PSCustomObject"))) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }

        - task: PowerShell@2
          displayName: "Generate backup parameters"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "$env:AGENT_TEMPDIRECTORY/backup_parameters.json"
              $json = @"
              {
              "Product.SystemName": "$(SYSTEM_NAME)",
              "Product.Database.BackupShare": "$('$(DATABASE_NETWORK_SHARE)' -replace '\\', '\\')",
              "Product.BackupDatabase.UseCompression": true,
              "Package[Product.Database.Online].Database.Server": "$('$(DATABASE_ONLINE_MSSQL_ADDRESS)' -replace '\\', '\\')",
              "Package[Product.Database.Online].Database.User": "$('$(DATABASE_ONLINE_MSSQL_USERNAME)' -replace '\\', '\\')",
              "Package[Product.Database.Online].Database.Password": "$('$(DATABASE_ONLINE_MSSQL_PASSWORD)' -replace '\\', '\\')"
              }
              "@
              $json | set-content $file
              Write-Host $json

        # TODO: avoid collision between Full and Daily backups, both will generate a Cmf.FullBackup.Online.<version>.zip
        - task: PowerShell@2
          displayName: "Daily Backup"
          inputs:
            targetType: 'inline'
            script: |
              Remove-Item -Path $(DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Force -Verbose
              Remove-Item -Path $(DATABASE_NETWORK_SHARE)/*.bak -Force -Verbose
              New-Item -ItemType Directory -Path "$(DATABASE_NETWORK_SHARE)" -Name "DailyBackup" -Force
              & tools\CmfDeploy.exe backup --parameters $env:AGENT_TEMPDIRECTORY/backup_parameters.json --packageSources .\DFPackages
              Move-Item -Path $(DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Destination $(DATABASE_NETWORK_SHARE)/DailyBackup  -Force
              Move-Item -Path $(DATABASE_NETWORK_SHARE)/*.bak -Destination $(DATABASE_NETWORK_SHARE)/DailyBackup  -Force
            pwsh: true
            workingDirectory: 'C:\tools\Cmf.Deployment.Framework'

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "RunTests"
    displayName: "Run Tests"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.RunTests }}', true) ) )
    jobs:
      - job: "RunTests"
        timeoutInMinutes: 720 # 12 hours
        displayName: "Run Tests"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        # Copy Copy global.json to root
        - task: CopyFiles@2
          displayName: 'Copy global.json to root'
          inputs:
            SourceFolder: Configurations
            Contents: 'global.json'
            TargetFolder: '.'

        # Download Tests Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Tests Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Tests'
            downloadPath: '$(Build.SourcesDirectory)'
          continueOnError: true

        # Verify if Artifact exists - Tests
        - task: PowerShell@2
          displayName: Verify if Artifact exists - Tests
          inputs:
            targetType: inline
            script: |
              Write-Host "##vso[task.setVariable variable=ArtifactExists;]false"
              $artifactPath = "$(Build.SourcesDirectory)/Tests/*.zip"
              Write-Host "$artifactPath"
              if (Get-ChildItem -Path $artifactPath)
              {
                ls $artifactPath
                Get-ChildItem $artifactPath | foreach {
                  $targetDirectory = "$(Build.SourcesDirectory)/TestExecution/" + $_.BaseName
                  Write-Host "$_ -> $targetDirectory"
                  Expand-Archive $_ -DestinationPath $targetDirectory -Force
                }
                Write-Host "##vso[task.setVariable variable=ArtifactExists;]true"
              }
              else
              {
                Write-Host "If fails"
              }
              Write-Host "$Env:ArtifactExists"

        # UseDotNet
        - task: UseDotNet@2
          displayName: 'Use Repository specified .NET Core version'
          inputs:
            packageType: 'sdk'
            useGlobalJson: true

        # Copy RunSettings to TestExecution
        - task: CopyFiles@2
          displayName: 'Copy RunSettings to TestExecution'
          inputs:
            SourceFolder: Configurations
            Contents: 'RunSettings/**'
            TargetFolder: 'TestExecution'

        # Run Tests - Business
        - task: VSTest@2
          displayName: "Run Tests - Business"
          inputs:
            testAssemblyVer2: '**\*.Biz.dll'
            searchFolder: $(System.DefaultWorkingDirectory)
            resultsFolder: '$(Agent.TempDirectory)\TestResults'
            runSettingsFile: 'TestExecution\RunSettings\${{ variables.RunSettings }}'
            testRunTitle: "Business Tests"
            rerunFailedTests: true
            rerunType: "basedOnTestFailurePercentage" # Optional. Options: basedOnTestFailurePercentage, basedOnTestFailureCount
            rerunFailedThreshold: "30"
            rerunMaxAttempts: "3"
          continueOnError: true
          condition: eq(variables['ArtifactExists'], true)

        # Run Tests - HTML
        - task: VSTest@2
          displayName: "Run Tests - HTML"
          inputs:
            testAssemblyVer2: '**\*.GUI.dll'
            searchFolder: $(System.DefaultWorkingDirectory)
            resultsFolder: '$(Agent.TempDirectory)\TestResults'
            runSettingsFile: 'TestExecution\RunSettings\${{ variables.RunSettings }}'
            testRunTitle: "HTML Tests"
            rerunFailedTests: true
            rerunType: "basedOnTestFailurePercentage" # Optional. Options: basedOnTestFailurePercentage, basedOnTestFailureCount
            rerunFailedThreshold: "30"
            rerunMaxAttempts: "3"
          continueOnError: true
          condition: eq(variables['ArtifactExists'], true)

        # Run Tests - IoT
        - task: VSTest@2
          displayName: "Run Tests - IoT"
          inputs:
            testAssemblyVer2: '**\*.IoT.dll'
            searchFolder: $(System.DefaultWorkingDirectory)
            resultsFolder: '$(Agent.TempDirectory)\TestResults'
            platform: latest
            runSettingsFile: 'TestExecution\RunSettings\${{ variables.RunSettings }}'
            testRunTitle: "IoT Tests"
            rerunFailedTests: true
            rerunType: "basedOnTestFailurePercentage" # Optional. Options: basedOnTestFailurePercentage, basedOnTestFailureCount
            rerunFailedThreshold: "30"
            rerunMaxAttempts: "3"
          continueOnError: true
          condition: eq(variables['ArtifactExists'], true)

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "ApprovalAndRetain"
    displayName: "Approval and Retain"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.ApprovalAndRetain }}', true) ) )
    jobs:
      - deployment:
        timeoutInMinutes: 2880 # 48 hours
        displayName: "Approval and Retain"
        workspace:
          clean: all
        environment: ${{ parameters.Environment }}
        cancelTimeoutInMinutes: 2880 # 48 hours
        strategy:
          runOnce:
            deploy:
              steps:
              - checkout: none

              # Download Configurations Artifacts
              - task: DownloadBuildArtifacts@0
                displayName: "Download Configurations Artifacts"
                inputs:
                  buildType: 'specific'
                  project: '<%= $CLI_PARAM_ProjectName %>'
                  pipeline: 'CI-Publish'
                  specificBuildWithTriggering: true
                  buildVersionToDownload: 'specific'
                  buildId: '$(resources.pipeline.CIPublish.runID)'
                  downloadType: 'single'
                  artifactName: 'Configurations'
                  downloadPath: '.'

              # Get package version
              - task: PowerShell@2
                displayName: 'Get package version'
                inputs:
                  targetType: inline
                  script: |
                    $PackageId = "${{ variables.RootPackageIdToInstall }}"
                    if($PackageId)
                    {
                      $PackageVersion = (Get-Item "${{ variables.CandidatePackages }}/Package/$PackageId*").BaseName -replace "$PackageId."
                    }
                    else
                    {
                      $CmfPackageJsonFile = Get-Item "./Configurations/cmfpackage.json"
                      $CmfPackageJson = Get-Content -Raw -Path $CmfPackageJsonFile | ConvertFrom-Json
                      $PackageId = $CmfPackageJson.'packageId'
                      $PackageVersion = $CmfPackageJson.'version'
                    }
                    echo "##vso[task.setvariable variable=PackageVersion;isOutput=true]$PackageVersion"
                    echo "##vso[task.setvariable variable=PackageId;isOutput=true]$PackageId"
                name: GetPackageVersion

              # Get Date
              - task: PowerShell@2
                displayName: "Get Date"
                inputs:
                  pwsh: false
                  targetType: inline
                  script: |
                    $date=$(Get-Date -Format "yyyyMMdd");
                    Write-Host "##vso[task.setvariable variable=time]$date"
                continueOnError: false

              # Tag Git Source
              - task: git-tag-on-release-task@9
                displayName: "Tag Git Source"
                inputs:
                  staticTagName: "<%= $CLI_PARAM_Tenant %>-$(time)-$(GetPackageVersion.PackageVersion)"

              # Retain indefinitely current release
              - task: retainPipeline@3
                displayName: "Retain indefinitely current release"
                inputs:
                  lock: true

              # Download Package Artifacts
              - task: DownloadBuildArtifacts@0
                displayName: "Download Package Artifacts"
                inputs:
                  buildType: 'specific'
                  project: '<%= $CLI_PARAM_ProjectName %>'
                  pipeline: 'CI-Publish'
                  specificBuildWithTriggering: true
                  buildVersionToDownload: 'specific'
                  buildId: '$(resources.pipeline.CIPublish.runID)'
                  downloadType: 'single'
                  artifactName: 'Package'
                  downloadPath: 'PackageApproved'

              # Copy generated Packages to Repository
              - task: CopyFiles@2
                displayName: 'Copy generated Packages From Repository'
                inputs:
                  SourceFolder: 'PackageApproved/Package'
                  Contents: |
                    *.zip
                  TargetFolder: '${{ variables.ApprovedPackages }}'
                  OverWrite: false

              # Download Tests Artifacts
              - task: DownloadBuildArtifacts@0
                displayName: "Download Tests Artifacts"
                inputs:
                  buildType: 'specific'
                  project: '<%= $CLI_PARAM_ProjectName %>'
                  pipeline: 'CI-Publish'
                  specificBuildWithTriggering: true
                  buildVersionToDownload: 'specific'
                  buildId: '$(resources.pipeline.CIPublish.runID)'
                  downloadType: 'single'
                  artifactName: 'Tests'
                  downloadPath: 'TestPackageApproved'

              # Copy generated Packages to Repository
              - task: CopyFiles@2
                displayName: 'Copy generated Packages To Repository'
                inputs:
                  SourceFolder: 'TestPackageApproved/Tests'
                  Contents: |
                    *.zip
                  TargetFolder: '${{ variables.ApprovedPackages }}'
                  OverWrite: false

              # Clean
              - task: PostBuildCleanup@3
                displayName: "Clean Agent Directories"
                condition: always()

  - stage: "SetNewRestorePoint"
    displayName: "Copy Full Backup packages to approved packages share"
    condition: or( and( eq('${{ variables.SetNewRestorePoint }}', true), eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.SetNewRestorePoint }}', true) ) )
    jobs:
      - job: "SetNewRestorePoint"
        displayName: "Copy Full Backup packages to approved packages share"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        - task: replacetokens@4
          displayName: 'Replace tokens in parameters files'
          inputs:
            rootDirectory: 'Configurations'
            targetFiles: '**/*.json'
            keepToken: true
            tokenPrefix: '#{'
            tokenSuffix: '}#'

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil -or ($_.Value.GetType().FullName -eq "System.Management.Automation.PSCustomObject"))) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }

        # Copy full backup packages to stack package path
        - task: PowerShell@2
          displayName: "Copy Cmf.FullBackup packages"
          inputs:
            pwsh: false
            targetType: inline
            failOnStderr: true
            script: |
                Copy-Item -Path $(DATABASE_NETWORK_SHARE)/FullBackup/Cmf.FullBackup.*.zip -Destination $(DATABASE_NETWORK_SHARE)/Approved -Verbose -Force -Recurse
          continueOnError: false

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()
=======
    # Clean Agent Directories
    - template: .tasks/clean-agent-directories.yml

- stage: Prepare_Environment
  displayName: Prepare Environment
  condition: |
    and(
      eq(stageDependencies.Artifacts.result, 'Succeeded'),
      or(
        eq('${{ parameters.ExecuteAllStages }}', true),
        and(eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.PrepareEnvironment }}', true))
      )
    )
  jobs:
  - job: DropDB_Job
    displayName: Drop Databases
    workspace:
      clean: all
    steps:
    - checkout: none

    # Load EnvironmentConfig and Package Info
    - template: .tasks/load-config.yml

    # Drop Online
    - template: .tasks/drop-db.yml
      parameters:
        DB: Online
        ServerName: $(EnvConfig.DATABASE_ONLINE_MSSQL_ADDRESS)

    # Drop ODS
    - template: .tasks/drop-db.yml
      parameters:
        DB: ODS
        ServerName: $(EnvConfig.DATABASE_ODS_MSSQL_ADDRESS)

    # Drop DWH
    - template: .tasks/drop-db.yml
      parameters:
        DB: DWH
        ServerName: $(EnvConfig.DATABASE_DWH_MSSQL_ADDRESS)

    # Copy Backup
    - task: CopyFiles@2
      displayName: Copy Backup
      inputs:
        SourceFolder: $(EnvConfig.DATABASE_NETWORK_SHARE)/Approved
        Contents: Cmf.FullBackup.*.zip
        TargetFolder: $(CandidatePackages)/Package

    # Clean Agent Directories
    - template: .tasks/clean-agent-directories.yml

- stage: Installation
  displayName: Installation
  condition: |
    and(
      eq(dependencies.Artifacts.result, 'Succeeded'),
      or(
        and(eq('${{ parameters.ExecuteAllStages }}', true), eq(dependencies.Prepare_Environment.result, 'Succeeded')),
        and(eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.Installation }}', true))
      )
    )
  jobs:
  - deployment: Deployment
    displayName: Customization
    workspace:
      clean: all
    steps:
    - checkout: none

    # Load EnvironmentConfig and Package Info
    - template: .tasks/load-config.yml

    # Install cmf-portal
    - template: .tasks/install-cmf-portal.yml

    # Portal Login
    - template: .tasks/portal-login.yml

    # Customization Install
    - template: .tasks/portal-deploy-customization.yml

    # Clean Agent Directories
    - template: .tasks/clean-agent-directories.yml

- stage: RestorePoint
  displayName: Restore Point
  condition: |
    and(
      eq(dependencies.Artifacts.result, 'Succeeded'),
      or(
        and(eq('${{ parameters.ExecuteAllStages }}', true), eq(dependencies.Installation.result, 'Succeeded')),
        and(eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.RestorePoint }}', true))
      )
    )
  jobs:
  - job: RestorePoint
    displayName: Restore Point
    workspace:
      clean: all
    steps:
    - checkout: none

    # Load EnvironmentConfig and Package Info
    - template: .tasks/load-config.yml

    # Delete previous Backup
    - pwsh: |
        Remove-Item -Path $(EnvConfig.DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Force -Verbose
        Remove-Item -Path $(EnvConfig.DATABASE_NETWORK_SHARE)/*.bak -Force -Verbose
        Remove-Item -Path $(EnvConfig.DATABASE_NETWORK_SHARE)/FullBackup -Force -Verbose -Recurse -ErrorAction Ignore
      displayName: Delete previous Backup

    # Backup
    - pwsh: |
        New-Item -ItemType Directory -Path "$(EnvConfig.DATABASE_NETWORK_SHARE)" -Name "FullBackup" -Force
        & tools\CmfDeploy.exe backup --parameters "$(EnvConfig.ConfigPath)" --packageSources .\DFPackages
        Move-Item -Path $(EnvConfig.DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Destination $(EnvConfig.DATABASE_NETWORK_SHARE)/FullBackup -Force
      displayName: Backup
      workingDirectory: C:\tools\Cmf.Deployment.Framework

    # Clean Agent Directories
    - template: .tasks/clean-agent-directories.yml

- stage: RunTestMasterData
  displayName: Run Test Master Data
  condition: |
    and(
      eq(dependencies.Artifacts.result, 'Succeeded'),
      or(
        and(eq('${{ parameters.ExecuteAllStages }}', true), eq(dependencies.RestorePoint.result, 'Succeeded')),
        and(eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.RunTestMasterData }}', true))
      )
    )
  jobs:
  - job: TestMasterDataArtifactsExists
    workspace:
      clean: all
    displayName: Artifacts Exists
    steps:
    - checkout: none

    # Verify if Artifact exists - TestMasterData
    - pwsh: |
        $testMasterDataFilter = "$(TestMasterDataFilter)"
        if(!$testMasterDataFilter) {
          $testMasterDataFilter = "*MasterData*"
        }
        $masterDataFiles = "$(CandidatePackages)/Tests/$testMasterDataFilter.zip"
        $exists = $false

        if (Get-ChildItem -Path $masterDataFiles) {
            $exists = $true
        }
        Write-Host "##vso[task.setVariable variable=Exists;isOutput=true]$exists"

        if(!$exists) {
          throw "Artifact not exists"
        }
      displayName: Verify if Artifact exists - TestMasterData
      name: TestMasterData
      continueOnError: true

  - job: RunTestMasterData
    displayName: Run Test Master Data
    dependsOn: TestMasterDataArtifactsExists
    condition: eq(dependencies.TestMasterDataArtifactsExists.outputs['TestMasterData.Exists'], true)
    workspace:
      clean: all
    steps:
    - checkout: none

    # Load EnvironmentConfig and Package Info
    - template: .tasks/load-config.yml

    # Install cmf-portal
    - template: .tasks/install-cmf-portal.yml

    # Portal Login
    - template: .tasks/portal-login.yml

    # Customization Install
    - template: .tasks/portal-deploy-masterdata.yml

    # Clean Agent Directories
    - template: .tasks/clean-agent-directories.yml

- stage: DailyBackup
  displayName: Daily Backup
  condition: |
    and(
      eq(dependencies.Artifacts.result, 'Succeeded'),
      or(
        and(eq('${{ parameters.ExecuteAllStages }}', true), eq(dependencies.RunTestMasterData.result, 'Succeeded')),
        and(eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.DailyBackup }}', true))
      )
    )
  jobs:
  - job: DailyBackup
    displayName: Daily Backup
    workspace:
      clean: all
    steps:
    - checkout: none

    # Load EnvironmentConfig and Package Info
    - template: .tasks/load-config.yml

    # Delete previous Backup
    - pwsh: |
        Remove-Item -Path $(EnvConfig.DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Force -Verbose
        Remove-Item -Path $(EnvConfig.DATABASE_NETWORK_SHARE)/*.bak -Force -Verbose
      displayName: Delete previous Backup

    # Backup
    - pwsh: |
        New-Item -ItemType Directory -Path "$(EnvConfig.DATABASE_NETWORK_SHARE)" -Name "DailyBackup" -Force
        & tools\CmfDeploy.exe backup --parameters "$(EnvConfig.ConfigPath)" --packageSources .\DFPackages
        Move-Item -Path $(EnvConfig.DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Destination $(EnvConfig.DATABASE_NETWORK_SHARE)/DailyBackup -Force
        Move-Item -Path $(EnvConfig.DATABASE_NETWORK_SHARE)/*.bak -Destination $(EnvConfig.DATABASE_NETWORK_SHARE)/DailyBackup -Force
      displayName: Backup
      workingDirectory: C:\tools\Cmf.Deployment.Framework

    # Clean Agent Directories
    - template: .tasks/clean-agent-directories.yml

- stage: RunTests
  displayName: Run Tests
  condition: |
    and(
      eq(dependencies.Artifacts.result, 'Succeeded'),
      or(
        and(eq('${{ parameters.ExecuteAllStages }}', true), eq(dependencies.DailyBackup.result, 'Succeeded')),
        and(eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.RunTests }}', true))
      )
    )
  jobs:
  - job: TestsArtifactsExists
    displayName: Artifacts Exists
    workspace:
      clean: all
    steps:
      - checkout: none

      # Verify if Artifact exists - Tests
      - pwsh: |
          $exists = $false
          $artifactPath = "$(CandidatePackages)/Tests/*.zip"
          if (Get-ChildItem -Path $artifactPath)
          {
            $exists = $true
          }
          Write-Host "##vso[task.setVariable variable=Exists;isOutput=true]$exists"

          if(!$exists) {
            throw "Artifact not exists"
          }
        displayName: Verify if Artifact exists - Tests
        name: Tests
        continueOnError: true

  - job: RunTests
    displayName: Run Tests
    dependsOn: TestsArtifactsExists
    condition: eq(dependencies.TestsArtifactsExists.outputs['Tests.Exists'], true)
    timeoutInMinutes: 720 # 12 hours
    workspace:
      clean: all
    steps:
      - checkout: none

      # Extract dlls
      - pwsh: |
          $artifactPath = "$(CandidatePackages)/Tests/*.zip"
          if (Get-ChildItem -Path $artifactPath)
          {
            Get-ChildItem $artifactPath | foreach {
              $targetDirectory = "$(Build.ArtifactStagingDirectory)/TestExecution/" + $_.BaseName
              Expand-Archive $_ -DestinationPath $targetDirectory -Force -Verbose
            }
          }
        displayName: Extract dlls

      # Copy Copy global.json to root
      - task: CopyFiles@2
        displayName: Copy global.json to root
        inputs:
          SourceFolder: $(CandidatePackages)/Configurations
          Contents: global.json
          TargetFolder: .

      # set dotnet version
      - template: .tasks/use-dotnet-version.yml

      # Run Tests - Business
      - template: .tasks/run-tests.yml
        parameters:
          TestAssembly: "**/*.Biz.dll"
          TestRunTitle: Business

      # Run Tests - GUI
      - template: .tasks/run-tests.yml
        parameters:
          TestAssembly: "**/*.GUI.dll"
          TestRunTitle: GUI

      # Run Tests - IoT
      - template: .tasks/run-tests.yml
        parameters:
          TestAssembly: "**/*.IoT.dll"
          TestRunTitle: IoT

      # Clean Agent Directories
      - template: .tasks/clean-agent-directories.yml

- stage: ApprovalAndRetain
  displayName: Approval and Retain
  condition: |
    and(
      eq(dependencies.Artifacts.result, 'Succeeded'),
      or(
        and(eq('${{ parameters.ExecuteAllStages }}', true), in(dependencies.RunTests.result, 'Succeeded', 'SucceededWithIssues')),
        and(eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.ApprovalAndRetain }}', true))
      )
    )
  jobs:
  - deployment:
    timeoutInMinutes: 2880 # 48 hours
    displayName: Approval and Retain
    workspace:
      clean: all
    environment: ApprovalGate
    cancelTimeoutInMinutes: 2880 # 48 hours
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: none

          # Load EnvironmentConfig and Package Info
          - template: .tasks/load-config.yml

          # Get Date
          - pwsh: |
              $date=$(Get-Date -Format "yyyyMMdd");
              Write-Host "##vso[task.setvariable variable=date]$date"
            displayName: Get Date

          # Tag Git Source
          - task: git-tag-on-release-task@9
            displayName: Tag Git Source
            inputs:
              staticTagName: $(EnvConfig.Product.Tenant.Name)-$(date)-$(EnvConfig.PackageVersion)

          # Retain indefinitely current release
          - task: retainPipeline@3
            displayName: Retain indefinitely current release
            inputs:
              lock: true

          # Download Package Artifacts
          - task: DownloadBuildArtifacts@0
            displayName: Download Package
            inputs:
              buildType: specific
              project: $(System.TeamProject)
              pipeline: CI-Publish
              specificBuildWithTriggering: true
              buildVersionToDownload: specific
              buildId: $(resources.pipeline.CIPublish.runID)
              downloadType: single
              artifactName: Package
              downloadPath: $(ApprovedPackages)

          # Download Tests Artifacts
          - task: DownloadBuildArtifacts@0
            displayName: Download Tests
            inputs:
              buildType: specific
              project: $(System.TeamProject)
              pipeline: CI-Publish
              specificBuildWithTriggering: true
              buildVersionToDownload: specific
              buildId: $(resources.pipeline.CIPublish.runID)
              downloadType: single
              artifactName: Tests
              downloadPath: $(ApprovedPackages)

          # Clean Agent Directories
          - template: .tasks/clean-agent-directories.yml

- stage: SetNewRestorePoint
  displayName: Set New RestorePoint
  condition: |
    and(
      eq(dependencies.Artifacts.result, 'Succeeded'),
      eq(variables['SetNewRestorePoint'], true),
      or(
        and(eq('${{ parameters.ExecuteAllStages }}', true), eq(dependencies.ApprovalAndRetain.result, 'Succeeded')),
        and(eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.SetNewRestorePoint }}', true))
      )
    )
  jobs:
  - job: SetNewRestorePoint
    displayName: Set New RestorePoint
    workspace:
        clean: all
    steps:
    - checkout: none

    # Load EnvironmentConfig and Package Info
    - template: .tasks/load-config.yml

    # Copy full backup packages to stack package path
    - pwsh:   |
        New-Item -Type Directory $(EnvConfig.DATABASE_NETWORK_SHARE)/Approved -Force
        Copy-Item -Path $(EnvConfig.DATABASE_NETWORK_SHARE)/FullBackup/Cmf.FullBackup.*.zip -Destination $(EnvConfig.DATABASE_NETWORK_SHARE)/Approved -Verbose -Force -Recurse
      displayName: Copy Cmf.FullBackup packages

    # Clean Agent Directories
    - template: .tasks/clean-agent-directories.yml
>>>>>>> Stashed changes
