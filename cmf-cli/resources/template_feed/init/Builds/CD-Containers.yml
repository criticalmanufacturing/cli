# CM PI Continuous Deployment Containers Pipeline
pool:
  name: Releases

# A pipeline with no CI trigger
trigger: none

# A pipeline with no PR trigger
pr: none

# Pipeline tiggered by CI-Publish
resources:
 pipelines:
   - pipeline: CIPublish
     source: CI-Publish
     branch: $(Build.SourceBranch)
     project: '<%= $CLI_PARAM_ProjectName %>'
     trigger:
      enabled: true

variables:
 - group: Docker Variables
 - template: ../EnvironmentConfigs/GlobalVariables.yml  # Template reference to global variables
 - template: ../EnvironmentConfigs/${{ parameters.Environment }}.yml  # Template reference to environment variables

# Set in runtime
parameters:
- name: Environment
  displayName: AzureDevOps Environment name
  type: string
  default: <%= $CLI_PARAM_EnvironmentName %>
  values:
  - <%= $CLI_PARAM_EnvironmentName %>
# Stages to Run
- name: ExecuteAllStages
  displayName: Execute All Stages
  type: boolean
  default: true
- name: DropDatabase
  displayName: Drop Database
  type: boolean
  default: false
- name: Installation
  displayName: Installation
  type: boolean
  default: false
- name: RestorePoint
  displayName: Restore Point
  type: boolean
  default: false
- name: RunTestMasterData
  displayName: Run Test MasterData
  type: boolean
  default: false
- name: DailyBackup
  displayName: Daily Backup
  type: boolean
  default: false
- name: RunTests
  displayName: Run Tests
  type: boolean
  default: false
- name: ApprovalAndRetain
  displayName: Approval and Retain
  type: boolean
  default: false
- name: SetNewRestorePoint
  displayName: Set New RestorePoint
  type: boolean
  default: false

name: Release-$(Build.BuildId)
stages:
  - stage: "DropDatabase"
    displayName: "Drop Database"
    condition: or( eq('${{ parameters.ExecuteAllStages }}', true), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.DropDatabase }}', true) ) )
    jobs:
      - job: "DropDatabase"
        displayName: "Drop Database"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil)) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }

        - task: SqlDacpacDeploymentOnMachineGroup@0
          displayName: "Drop ONLINE database"
          inputs:
            TaskType: 'sqlInline'
            InlineSql: |
              IF EXISTS (SELECT name from sys.databases WHERE (name = N'$(SYSTEM_NAME)'))
              BEGIN
                EXEC msdb.dbo.sp_delete_database_backuphistory @database_name = N'$(SYSTEM_NAME)'
                ALTER DATABASE [$(SYSTEM_NAME)] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
                DROP DATABASE IF EXISTS $(SYSTEM_NAME)
              END;
            ServerName: '$(DATABASE_ONLINE_MSSQL_ADDRESS)'
            DatabaseName: 'master'
            AuthScheme: 'sqlServerAuthentication'
            SqlUsername: '$(DATABASE_ONLINE_MSSQL_USERNAME)'
            SqlPassword: '$(DATABASE_ONLINE_MSSQL_PASSWORD)'

        - task: SqlDacpacDeploymentOnMachineGroup@0
          displayName: "Drop ODS database"
          inputs:
            TaskType: 'sqlInline'
            InlineSql: |
              IF EXISTS (SELECT name from sys.databases WHERE (name = N'$(SYSTEM_NAME)ODS'))
              BEGIN
                EXEC msdb.dbo.sp_delete_database_backuphistory @database_name = N'$(SYSTEM_NAME)ODS'
                ALTER DATABASE [$(SYSTEM_NAME)ODS] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
                DROP DATABASE IF EXISTS $(SYSTEM_NAME)ODS
              END;
            ServerName: '$(DATABASE_ODS_MSSQL_ADDRESS)'
            DatabaseName: 'master'
            AuthScheme: 'sqlServerAuthentication'
            SqlUsername: '$(DATABASE_ODS_MSSQL_USERNAME)'
            SqlPassword: '$(DATABASE_ODS_MSSQL_PASSWORD)'

        - task: SqlDacpacDeploymentOnMachineGroup@0
          displayName: "Drop DWH database"
          inputs:
            TaskType: 'sqlInline'
            InlineSql: |
              IF EXISTS (SELECT name from sys.databases WHERE (name = N'$(SYSTEM_NAME)DWH'))
              BEGIN
                EXEC msdb.dbo.sp_delete_database_backuphistory @database_name = N'$(SYSTEM_NAME)DWH'
                ALTER DATABASE [$(SYSTEM_NAME)DWH] SET SINGLE_USER WITH ROLLBACK IMMEDIATE
                DROP DATABASE IF EXISTS $(SYSTEM_NAME)DWH
              END;
            ServerName: '$(DATABASE_DWH_MSSQL_ADDRESS)'
            DatabaseName: 'master'
            AuthScheme: 'sqlServerAuthentication'
            SqlUsername: '$(DATABASE_DWH_MSSQL_USERNAME)'
            SqlPassword: '$(DATABASE_DWH_MSSQL_PASSWORD)'

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "Installation"
    displayName: "Installation"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.Installation }}', true) ) )
    jobs:
      - job: "Installation"
        displayName: "Installation"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Clean deploy folder
        - task: DeleteFiles@1
          displayName: 'Clean deploy folder'
          inputs:
            SourceFolder: '${{ variables.CandidatePackages }}'
            Contents: '**'

        # Download Package Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Package Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Package'
            downloadPath: '${{ variables.CandidatePackages }}'

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        # Copy External Package Dependencies
        # use Node Tool
        - task: NodeTool@0
          displayName: 'Use Node ${{ variables.NodeVersion }}'
          inputs:
            versionSpec: ${{ variables.NodeVersion }}

        # Install cmf-pipeline
        - task: PowerShell@2
          displayName: 'Install cmf-pipeline@${{ variables.CmfPipelineVersion }}'
          inputs:
            pwsh: true
            failOnStderr: false
            workingDirectory: $(Agent.TempDirectory)
            targetType: inline
            script: |
              npm install --no-save @criticalmanufacturing/cmf-pipeline@${{ variables.CmfPipelineVersion }} --registry ${{ variables.CmfPipelineRepository }}

        - task: PowerShell@2
          displayName: "cmf-pipeline copyDependencies"
          inputs:
            targetType: 'inline'
            script: |
              $(Agent.TempDirectory)/node_modules/@criticalmanufacturing/cmf-pipeline/dist/win-x64/cmf-pipeline copyDependencies Configurations/dependencies.json ${{ variables.CandidatePackages }}/Package
            pwsh: true

        - task: replacetokens@4
          displayName: 'Replace tokens in parameters files'
          inputs:
            rootDirectory: 'Configurations'
            targetFiles: '**/*.json'
            keepToken: true
            tokenPrefix: '#{'
            tokenSuffix: '}#'

        - task: PowerShell@2
          displayName: "Get portal-sdk"
          inputs:
            pwsh: true
            failOnStderr: false
            workingDirectory: $(Agent.TempDirectory)
            targetType: inline
            script: |
              npm install --no-save @criticalmanufacturing/portal --registry ${{ variables.CmfCliRepository }}

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil)) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }

        - task: PowerShell@2
          displayName: "Generate Environment Installation Parameters"
          inputs:
            targetType: 'inline'
            failOnStderr: true
            pwsh: true
            script: |
              $CmfPackageJsonFile = Get-Item "./Configurations/cmfpackage.json"
              $CmfPackageJson = Get-Content -Raw -Path $CmfPackageJsonFile | ConvertFrom-Json

              $PackageId = $CmfPackageJson.'packageId'
              $PackageVersion = $CmfPackageJson.'version'
              $PackageIdentifier = $PackageId + '@' + $PackageVersion

              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
              $envConfig.ENV_MANAGER_BOOT_PACKAGE = $PackageIdentifier

              Write-Output "Installing package $PackageIdentifier"
              $envConfig | ConvertTo-Json -Depth 10 | set-content "$(Agent.TempDirectory)/install-package.json"

        # Installation with customization
        - task: PowerShell@2
          displayName: "Installation"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $packageSourceShare = "$(CandidatePackages)/Package"
              Copy-Item -Path $(DATABASE_NETWORK_SHARE)/approved/Cmf.FullBackup.*.zip -Destination $packageSourceShare -Force -Verbose
              if (Test-Path "Configurations/EnvironmentConfigs/devopscenter.qa.json" -PathType leaf)
              {
                Copy-Item -Path Configurations/EnvironmentConfigs/devopscenter.qa.json -Destination $env:AGENT_TEMPDIRECTORY/node_modules/@criticalmanufacturing/portal/bin/appsettings.json -Force
              }
              & $env:AGENT_TEMPDIRECTORY/node_modules/@criticalmanufacturing/portal/bin/cmf-portal.exe login --token $(CustomerPortalPAT) --verbose
              & $env:AGENT_TEMPDIRECTORY/node_modules/@criticalmanufacturing/portal/bin/cmf-portal.exe deploy `
                --name "${{ variables.CustomerEnvironmentName }}" `
                --customer-infrastructure-name "DS Integration Environments" `
                --parameters "$(Agent.TempDirectory)/install-package.json" `
                --license "${{ variables.LicenseName }}" `
                --site "${{ variables.SiteName }}" `
                --target "${{ variables.DeploymentTarget }}" `
                --package="${{ variables.DeploymentPackage }}" `
                --terminateOtherVersions --verbose

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "RestorePoint"
    displayName: "Restore Point"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.RestorePoint }}', true) ) )
    jobs:
      - job: "RestorePoint"
        displayName: "Restore Point"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil)) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }

        - task: PowerShell@2
          displayName: "Generate backup parameters"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "$env:AGENT_TEMPDIRECTORY/backup_parameters.json"
              $json = @"
              {
              "Product.SystemName": "$(SYSTEM_NAME)",
              "Product.Database.BackupShare": "$('$(DATABASE_NETWORK_SHARE)' -replace '\\', '\\')",
              "Product.BackupDatabase.UseCompression": true,
              "Package[Product.Database.Online].Database.Server": "$('$(DATABASE_ONLINE_MSSQL_ADDRESS)' -replace '\\', '\\')",
              "Package[Product.Database.Online].Database.User": "$('$(DATABASE_ONLINE_MSSQL_USERNAME)' -replace '\\', '\\')",
              "Package[Product.Database.Online].Database.Password": "$('$(DATABASE_ONLINE_MSSQL_PASSWORD)' -replace '\\', '\\')",
              "Package[Product.Database.Ods].Database.Server": "$('$(DATABASE_ODS_MSSQL_ADDRESS)' -replace '\\', '\\')",
              "Package[Product.Database.Ods].Database.User": "$('$(DATABASE_ODS_MSSQL_USERNAME)' -replace '\\', '\\')",
              "Package[Product.Database.Ods].Database.Password": "$('$(DATABASE_ODS_MSSQL_PASSWORD)' -replace '\\', '\\')",
              "Package[Product.Database.Dwh].Database.Server": "$('$(DATABASE_DWH_MSSQL_ADDRESS)' -replace '\\', '\\')",
              "Package[Product.Database.Dwh].Database.User": "$('$(DATABASE_DWH_MSSQL_USERNAME)' -replace '\\', '\\')",
              "Package[Product.Database.Dwh].Database.Password": "$('$(DATABASE_DWH_MSSQL_PASSWORD)' -replace '\\', '\\')"
              }
              "@
              $json | set-content $file
              Write-Host $json

        - task: PowerShell@2
          displayName: "Full Backup"
          inputs:
            targetType: 'inline'
            script: |
              Remove-Item -Path $(DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Force -Verbose
              Remove-Item -Path $(DATABASE_NETWORK_SHARE)/*.bak -Force -Verbose
              Remove-Item -Path $(DATABASE_NETWORK_SHARE)/FullBackup -Force -Verbose -Recurse -ErrorAction Ignore
              New-Item -ItemType Directory -Path "$(DATABASE_NETWORK_SHARE)" -Name "FullBackup" -Force
              & tools\CmfDeploy.exe backup --parameters $env:AGENT_TEMPDIRECTORY/backup_parameters.json --packageSources .\DFPackages
              Move-Item -Path $(DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Destination $(DATABASE_NETWORK_SHARE)/FullBackup -Force
            pwsh: true
            workingDirectory: 'C:\tools\Cmf.Deployment.Framework'

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "RunTestMasterData"
    displayName: "Run Test Master Data"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.RunTestMasterData }}', true) ) )
    jobs:
      - job: "RunTestMasterData"
        displayName: "Run Test Master Data"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        # Download Tests Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Tests Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Tests'
            downloadPath: '${{ variables.CandidatePackages }}'
          continueOnError: true

        # Verify if Artifact exists - Tests.MasterData
        - task: PowerShell@2
          displayName: Verify if Artifact exists - Tests.MasterData
          inputs:
            targetType: inline
            script: |
                $masterDataFiles = "${{ variables.CandidatePackages }}/Tests/*MasterData*.zip"
                Write-Host "##vso[task.setVariable variable=ArtifactExists;]false"

                if (Get-ChildItem -Path $masterDataFiles)
                {
                    Write-Host "##vso[task.setVariable variable=ArtifactExists;]true"
                }

        - task: replacetokens@4
          displayName: 'Replace tokens in parameters files'
          inputs:
            rootDirectory: 'Configurations'
            targetFiles: '**/*.json'
            keepToken: true
            tokenPrefix: '#{'
            tokenSuffix: '}#'

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil)) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }
        - task: PowerShell@2
          displayName: "Generate parameters"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "$env:AGENT_TEMPDIRECTORY/parameters.json"
              $json = @"
              {
              "Product.SystemName": "$(SYSTEM_NAME)",
              "Packages.Root.TargetDirectory": "",
              "Package[Product.Database.Online].Database.Server": "$('$(DATABASE_ONLINE_MSSQL_ADDRESS)' -replace '\\', '\\')",
              "Package[Product.Database.Online].Database.User": "$('$(DATABASE_ONLINE_MSSQL_USERNAME)' -replace '\\', '\\')",
              "Package[Product.Database.Online].Database.Password": "$('$(DATABASE_ONLINE_MSSQL_PASSWORD)' -replace '\\', '\\')",
              }
              "@
              $json | set-content $file
              Write-Host $json

        - task: PowerShell@2
          displayName: "MasterData Loading"
          inputs:
            targetType: 'inline'
            script: |
              $masterDataFiles = "${{ variables.CandidatePackages }}/Tests/*MasterData*.zip"

              Get-ChildItem $masterDataFiles | foreach {
                  $PackageId = [regex]::split($_.BaseName, ".[0-9]+.[0-9]+.[0-9]+")[0];
                  $PackageVersion = ($_.BaseName-replace "$PackageId." );

                  $PackageIdentifier = $PackageId + '@' + $PackageVersion

                  & tools\CmfDeploy.exe install $PackageIdentifier --parameters $env:AGENT_TEMPDIRECTORY/parameters.json --packageSources="${{ variables.CandidatePackages }}/Tests" -logFileLocation "${{ variables.CandidatePackages }}"
              }

            pwsh: true
            workingDirectory: 'C:\tools\Cmf.Deployment.Framework'
          condition: eq(variables['ArtifactExists'], true)

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "DailyBackup"
    displayName: "Daily Backup"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.DailyBackup }}', true) ) )
    jobs:
      - job: "DailyBackup"
        displayName: "Daily Backup"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil)) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }

        - task: PowerShell@2
          displayName: "Generate backup parameters"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "$env:AGENT_TEMPDIRECTORY/backup_parameters.json"
              $json = @"
              {
              "Product.SystemName": "$(SYSTEM_NAME)",
              "Product.Database.BackupShare": "$('$(DATABASE_NETWORK_SHARE)' -replace '\\', '\\')",
              "Product.BackupDatabase.UseCompression": true,
              "Package[Product.Database.Online].Database.Server": "$('$(DATABASE_ONLINE_MSSQL_ADDRESS)' -replace '\\', '\\')",
              "Package[Product.Database.Online].Database.User": "$('$(DATABASE_ONLINE_MSSQL_USERNAME)' -replace '\\', '\\')",
              "Package[Product.Database.Online].Database.Password": "$('$(DATABASE_ONLINE_MSSQL_PASSWORD)' -replace '\\', '\\')"
              }
              "@
              $json | set-content $file
              Write-Host $json

        # TODO: avoid colision between Full and Daily backups, both will generate a Cmf.FullBackup.Online.<version>.zip
        - task: PowerShell@2
          displayName: "Daily Backup"
          inputs:
            targetType: 'inline'
            script: |
              Remove-Item -Path $(DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Force -Verbose
              Remove-Item -Path $(DATABASE_NETWORK_SHARE)/*.bak -Force -Verbose
              New-Item -ItemType Directory -Path "$(DATABASE_NETWORK_SHARE)" -Name "DailyBackup" -Force
              & tools\CmfDeploy.exe backup --parameters $env:AGENT_TEMPDIRECTORY/backup_parameters.json --packageSources .\DFPackages
              Move-Item -Path $(DATABASE_NETWORK_SHARE)/Cmf.FullBackup.*.zip -Destination $(DATABASE_NETWORK_SHARE)/DailyBackup  -Force
              Move-Item -Path $(DATABASE_NETWORK_SHARE)/*.bak -Destination $(DATABASE_NETWORK_SHARE)/DailyBackup  -Force
            pwsh: true
            workingDirectory: 'C:\tools\Cmf.Deployment.Framework'

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "RunTests"
    displayName: "Run Tests"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.RunTests }}', true) ) )
    jobs:
      - job: "RunTests"
        timeoutInMinutes: 720 # 12 hours
        displayName: "Run Tests"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        # Copy Copy global.json to root
        - task: CopyFiles@2
          displayName: 'Copy global.json to root'
          inputs:
            SourceFolder: Configurations
            Contents: 'global.json'
            TargetFolder: '.'

        # Download Tests Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Tests Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Tests'
            downloadPath: '$(Build.SourcesDirectory)'
          continueOnError: true

        # Verify if Artifact exists - Tests
        - task: PowerShell@2
          displayName: Verify if Artifact exists - Tests
          inputs:
            targetType: inline
            script: |
              Write-Host "##vso[task.setVariable variable=ArtifactExists;]false"
              $artifactPath = "$(Build.SourcesDirectory)/Tests/*.zip"
              Write-Host "$artifactPath"
              if (Get-ChildItem -Path $artifactPath)
              {
                ls $artifactPath
                Get-ChildItem $artifactPath | foreach { 
                  $targetDirectory = "$(Build.SourcesDirectory)/TestExecution/" + $_.BaseName
                  Write-Host "$_ -> $targetDirectory"
                  Expand-Archive $_ -DestinationPath $targetDirectory -Force 
                }
                Write-Host "##vso[task.setVariable variable=ArtifactExists;]true"
              }
              else
              {
                Write-Host "If fails"
              }
              Write-Host "$Env:ArtifactExists"

        # UseDotNet
        - task: UseDotNet@2
          displayName: 'Use Repository specified .NET Core version'
          inputs:
            packageType: 'sdk'
            useGlobalJson: true

        # Copy RunSettings to TestExecution
        - task: CopyFiles@2
          displayName: 'Copy RunSettings to TestExecution'
          inputs:
            SourceFolder: Configurations
            Contents: 'RunSettings/**'
            TargetFolder: 'TestExecution'

        # Run Tests - Business
        - task: VSTest@2
          displayName: "Run Tests - Business"
          inputs:
            testAssemblyVer2: '**\*.Biz.dll'
            searchFolder: $(System.DefaultWorkingDirectory)
            resultsFolder: '$(Agent.TempDirectory)\TestResults'
            runSettingsFile: 'TestExecution\RunSettings\${{ variables.RunSettings }}'
            testRunTitle: "Business Tests"
            rerunFailedTests: true
            rerunType: "basedOnTestFailurePercentage" # Optional. Options: basedOnTestFailurePercentage, basedOnTestFailureCount
            rerunFailedThreshold: "30"
            rerunMaxAttempts: "3"
          continueOnError: true
          condition: eq(variables['ArtifactExists'], true)

        # Run Tests - HTML
        - task: VSTest@2
          displayName: "Run Tests - HTML"
          inputs:
            testAssemblyVer2: '**\*.GUI.dll'
            searchFolder: $(System.DefaultWorkingDirectory)
            resultsFolder: '$(Agent.TempDirectory)\TestResults'
            runSettingsFile: 'TestExecution\RunSettings\${{ variables.RunSettings }}'
            testRunTitle: "HTML Tests"
            rerunFailedTests: true
            rerunType: "basedOnTestFailurePercentage" # Optional. Options: basedOnTestFailurePercentage, basedOnTestFailureCount
            rerunFailedThreshold: "30"
            rerunMaxAttempts: "3"
          continueOnError: true
          condition: eq(variables['ArtifactExists'], true)

        # Run Tests - IoT
        - task: VSTest@2
          displayName: "Run Tests - IoT"
          inputs:
            testAssemblyVer2: '**\*.IoT.dll'
            searchFolder: $(System.DefaultWorkingDirectory)
            resultsFolder: '$(Agent.TempDirectory)\TestResults'
            platform: latest
            runSettingsFile: 'TestExecution\RunSettings\${{ variables.RunSettings }}'
            testRunTitle: "IoT Tests"
            rerunFailedTests: true
            rerunType: "basedOnTestFailurePercentage" # Optional. Options: basedOnTestFailurePercentage, basedOnTestFailureCount
            rerunFailedThreshold: "30"
            rerunMaxAttempts: "3"
          continueOnError: true
          condition: eq(variables['ArtifactExists'], true)

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "ApprovalAndRetain"
    displayName: "Approval and Retain"
    condition: or( and( eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.ApprovalAndRetain }}', true) ) )
    jobs:
      - deployment:
        timeoutInMinutes: 2880 # 48 hours
        displayName: "Approval and Retain"
        workspace:
          clean: all
        environment: ${{ parameters.Environment }}
        cancelTimeoutInMinutes: 2880 # 48 hours
        strategy:
          runOnce:
            deploy:
              steps:
              - checkout: none

              # Download Configurations Artifacts
              - task: DownloadBuildArtifacts@0
                displayName: "Download Configurations Artifacts"
                inputs:
                  buildType: 'specific'
                  project: '<%= $CLI_PARAM_ProjectName %>'
                  pipeline: 'CI-Publish'
                  specificBuildWithTriggering: true
                  buildVersionToDownload: 'specific'
                  buildId: '$(resources.pipeline.CIPublish.runID)'
                  downloadType: 'single'
                  artifactName: 'Configurations'
                  downloadPath: '.'

              # Get package version
              - task: PowerShell@2
                displayName: 'Get package version'
                inputs:
                  targetType: inline
                  script: |
                    $CmfPackageJsonFile = Get-Item "./Configurations/cmfpackage.json"
                    $CmfPackageJson = Get-Content -Raw -Path $CmfPackageJsonFile | ConvertFrom-Json
                    $PackVersion = $CmfPackageJson.'version'
                    $PackageId = $CmfPackageJson.'packageId'
                    Write-Host "PackVersion = $PackVersion"
                    Write-Host "PackageId = $PackageId"
                    echo "##vso[task.setvariable variable=PackageVersion;isOutput=true]$PackVersion"
                    echo "##vso[task.setvariable variable=PackageId;isOutput=true]$PackageId"
                name: GetPackageVersion

              # Get Date
              - task: PowerShell@2
                displayName: "Get Date"
                inputs:
                  pwsh: false
                  targetType: inline
                  script: |
                    $date=$(Get-Date -Format "yyyyMMdd");
                    Write-Host "##vso[task.setvariable variable=time]$date"
                continueOnError: false

              # Tag Git Source
              - task: git-tag-on-release-task@9
                displayName: "Tag Git Source"
                inputs:
                  staticTagName: "<%= $CLI_PARAM_Tenant %>-$(time)-$(GetPackageVersion.PackageVersion)"

              # Retain indefinitely current release
              - task: retainPipeline@3
                displayName: "Retain indefinitely current release"
                inputs:
                  lock: true

              # Download Package Artifacts
              - task: DownloadBuildArtifacts@0
                displayName: "Download Package Artifacts"
                inputs:
                  buildType: 'specific'
                  project: '<%= $CLI_PARAM_ProjectName %>'
                  pipeline: 'CI-Publish'
                  specificBuildWithTriggering: true
                  buildVersionToDownload: 'specific'
                  buildId: '$(resources.pipeline.CIPublish.runID)'
                  downloadType: 'single'
                  artifactName: 'Package'
                  downloadPath: 'PackageApproved'

              # Copy generated Packages to Repository
              - task: CopyFiles@2
                displayName: 'Copy generated Packages From Repository'
                inputs:
                  SourceFolder: 'PackageApproved/Package'
                  Contents: |
                    *.zip
                  TargetFolder: '${{ variables.ApprovedPackages }}'
                  OverWrite: false

              # Download Tests Artifacts
              - task: DownloadBuildArtifacts@0
                displayName: "Download Tests Artifacts"
                inputs:
                  buildType: 'specific'
                  project: '<%= $CLI_PARAM_ProjectName %>'
                  pipeline: 'CI-Publish'
                  specificBuildWithTriggering: true
                  buildVersionToDownload: 'specific'
                  buildId: '$(resources.pipeline.CIPublish.runID)'
                  downloadType: 'single'
                  artifactName: 'Tests'
                  downloadPath: 'TestPackageApproved'

              # Copy generated Packages to Repository
              - task: CopyFiles@2
                displayName: 'Copy generated Packages To Repository'
                inputs:
                  SourceFolder: 'TestPackageApproved/Tests'
                  Contents: |
                    *.zip
                  TargetFolder: '${{ variables.ApprovedPackages }}'
                  OverWrite: false

              # Clean
              - task: PostBuildCleanup@3
                displayName: "Clean Agent Directories"
                condition: always()

  - stage: "SetNewRestorePoint"
    displayName: "Copy Full Backup packages to approved packages share"
    condition: or( and( eq('${{ variables.SetNewRestorePoint }}', true), eq('${{ parameters.ExecuteAllStages }}', true), succeeded() ), and( eq('${{ parameters.ExecuteAllStages }}', false), eq('${{ parameters.SetNewRestorePoint }}', true) ) )
    jobs:
      - job: "SetNewRestorePoint"
        displayName: "Copy Full Backup packages to approved packages share"
        workspace:
          clean: all
        steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        - task: PowerShell@2
          displayName: "Load environment config"
          inputs:
            pwsh: true
            targetType: 'inline'
            script: |
              $file = "Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
              if (Test-Path -Path $file -PathType Leaf) {
                  $envConfig = Get-Content "$file" | out-string | ConvertFrom-Json
                  $envConfig.PSObject.Properties | ForEach-Object {
                      if (-not($_.Value -eq "" -or $_.Value -eq $nil)) {
                          Write-Output "##vso[task.setvariable variable=$($_.Name)]$($_.Value)"
                      }
                  }
              } else {
                  Write-Output "'$file' not found"
              }

        # Copy full backup packages to stack package path
        - task: PowerShell@2
          displayName: "Copy Cmf.FullBackup packages"
          inputs:
            pwsh: false
            targetType: inline
            failOnStderr: true
            script: |
                Copy-Item -Path $(DATABASE_NETWORK_SHARE)/FullBackup/Cmf.FullBackup.*.zip -Destination $(DATABASE_NETWORK_SHARE)/Approved -Verbose -Force -Recurse
          continueOnError: false

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()
