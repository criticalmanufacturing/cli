# CM PI Continuous Integration Release Pipeline
pool:
  name: <%= $CLI_PARAM_AgentPool %>
//#if (agentType == "Cloud")
  vmImage: 'ubuntu-latest'
//#endif

# A pipeline with no CI trigger
trigger: none

# A pipeline with no PR trigger
pr: none

# Pipeline tiggered by CI-Publish
resources:
 pipelines:
   - pipeline: CIPublish
     source: CI-Publish
     branch: $(Build.SourceBranch)
     project: '<%= $CLI_PARAM_ProjectName %>'
     trigger: true

variables:
 - template: ../EnvironmentConfigs/GlobalVariables.yml  # Template reference to global variables
 - template: ../EnvironmentConfigs/${{ parameters.Environment }}.yml  # Template reference to environment variables
 - name: RestoreIdentifier
   value: 'ORIGINAL'

# Setted in runtime
parameters:
- name: Environment
  displayName: AzureDevOps Environment name
  type: string
  default: <%= $CLI_PARAM_EnvironmentName %>
  values:
  - <%= $CLI_PARAM_EnvironmentName %>
# Stages to Run
- name: executeAllStages
  displayName: ExecuteAllStages
  type: boolean
  default: true
- name: RestoreEnvironment
  displayName: RestoreEnvironment
  type: boolean
  default: false
- name: CustomizationInstall
  displayName: CustomizationInstall
  type: boolean
  default: false
- name: RestorePoint
  displayName: RestorePoint
  type: boolean
  default: false
- name: RunTestMasterData
  displayName: RunTestMasterData
  type: boolean
  default: false
- name: DailyBackup
  displayName: DailyBackup
  type: boolean
  default: false
- name: RunTests
  displayName: RunTests
  type: boolean
  default: false
- name: ApprovalAndRetain
  displayName: ApprovalAndRetain
  type: boolean
  default: false
- name: RenameRestorePoint
  displayName: RenameRestorePoint
  type: boolean
  default: false

name: Release-$(Build.BuildId)
stages:
  - stage: "RestoreEnvironment"
    displayName: "Restore Environment"
    condition: or( eq('${{ parameters.executeAllStages }}', true), and( eq('${{ parameters.executeAllStages }}', false), eq('${{ parameters.RestoreEnvironment }}', true) ) )
    jobs:
      - job: "RestoreEnvironment"
        displayName: "Restore Environment"
        workspace:
          clean: all
        steps:
          - checkout: none

          # Download Configurations Artifacts
          - task: DownloadBuildArtifacts@0
            displayName: "Download Configurations Artifacts"
            inputs:
              buildType: 'specific'
              project: '<%= $CLI_PARAM_ProjectName %>'
              pipeline: 'CI-Publish'
              specificBuildWithTriggering: true
              buildVersionToDownload: 'specific'
              buildId: '$(resources.pipeline.CIPublish.runID)'
              downloadType: 'single'
              artifactName: 'Configurations'
              downloadPath: '.'

          # Download Build Artifacts - BackupRestore Tools
          - task: DownloadBuildArtifacts@0
            displayName: 'Download Build Artifacts - BackupRestore Tools'
            inputs:
              buildType: specific
              project: 'COMMON'
              pipeline: 'CI-BackupRestoreTools'
              specificBuildWithTriggering: true
              buildVersionToDownload: latestFromBranch
              branchName: '${{ variables.CommonBranch }}'
              downloadType: specific
              downloadPath: 'DownloadPackages'
              artifactName: Cmf.BackupRestore.Tools

          # Extract files - BackupRestoreTools
          - task: ExtractFiles@1
            displayName: "Extract files - Pre-Package"
            inputs:
              archiveFilePatterns: "Cmf.BackupRestore.Tools.*.zip"
              destinationFolder: "BackupRestoreTools"
              cleanDestinationFolder: true
            continueOnError: false

          # Copy EnvironmentConfig to Server
          - task: CopyFiles@2
            displayName: 'Copy EnvironmentConfig to Server'
            inputs:
              SourceFolder: Configurations/EnvironmentConfigs
              Contents: '${{ variables.EnvironmentConfigName }}'
              TargetFolder: BackupRestoreTools/EnvironmentConfigs

          # Restore DB
          - task: PowerShell@2
            displayName: "Restore DB"
            inputs:
              pwsh: false
              targetType: filePath
              filePath: '.\BackupRestoreTools\DeploymentTools\SystemRestore.ps1'
              arguments: '-EnvironmentConfigName ${{ variables.EnvironmentConfigName }} -InteractiveMode:$false -restoreIdentifier "$(RestoreIdentifier)" -FullRestore:$false -RestoreDBOnline:$true -RestoreDBODS:$true -RestoreDBDWH:$true -doNotStopHosts:$true'
            continueOnError: false

          # Restore Business Tier
          - task: PowerShell@2
            displayName: "Restore Business Tier"
            inputs:
              pwsh: false
              targetType: filePath
              filePath: '.\BackupRestoreTools\DeploymentTools\SystemRestore.ps1'
              arguments: '-EnvironmentConfigName ${{ variables.EnvironmentConfigName }} -InteractiveMode:$false -restoreIdentifier "$(RestoreIdentifier)" -FullRestore:$false -RestoreBusiness:$true'
            continueOnError: false

          # Restore HTML
          - task: PowerShell@2
            displayName: "Restore HTML"
            inputs:
              pwsh: false
              targetType: filePath
              filePath: '.\BackupRestoreTools\DeploymentTools\SystemRestore.ps1'
              arguments: '-EnvironmentConfigName ${{ variables.EnvironmentConfigName }} -InteractiveMode:$false -restoreIdentifier "$(RestoreIdentifier)" -FullRestore:$false -RestoreUIHtml:$true -doNotStopHosts:$true'
            continueOnError: false

          # Restore Help
          - task: PowerShell@2
            displayName: "Restore Help"
            inputs:
              pwsh: false
              targetType: filePath
              filePath: '.\BackupRestoreTools\DeploymentTools\SystemRestore.ps1'
              arguments: '-EnvironmentConfigName ${{ variables.EnvironmentConfigName }} -InteractiveMode:$false -restoreIdentifier "$(RestoreIdentifier)" -FullRestore:$false -RestoreUIHelp:$true -doNotStopHosts:$true'
            continueOnError: false

          # Clean
          - task: PostBuildCleanup@3
            displayName: "Clean Agent Directories"
            condition: always()

  - stage: "CustomizationInstall"
    displayName: "Customization Install"
    condition: or( and( eq('${{ parameters.executeAllStages }}', true), succeeded() ), and( eq('${{ parameters.executeAllStages }}', false), eq('${{ parameters.CustomizationInstall }}', true) ) )
    jobs:
      - job: "CustomizationInstall"
        displayName: "Customization Install"
        workspace:
          clean: all
        steps:
          - checkout: none

          # Clean deploy folder
          - task: DeleteFiles@1
            displayName: 'Clean deploy folder'
            inputs:
              SourceFolder: '${{ variables.CandidatePackages }}'
              Contents: '**'

          # Download Package Artifacts
          - task: DownloadBuildArtifacts@0
            displayName: "Download Package Artifacts"
            inputs:
              buildType: 'specific'
              project: '<%= $CLI_PARAM_ProjectName %>'
              pipeline: 'CI-Publish'
              specificBuildWithTriggering: true
              buildVersionToDownload: 'specific'
              buildId: '$(resources.pipeline.CIPublish.runID)'
              downloadType: 'single'
              artifactName: 'Package'
              downloadPath: '${{ variables.CandidatePackages }}'

          # Download Configurations Artifacts
          - task: DownloadBuildArtifacts@0
            displayName: "Download Configurations Artifacts"
            inputs:
              buildType: 'specific'
              project: '<%= $CLI_PARAM_ProjectName %>'
              pipeline: 'CI-Publish'
              specificBuildWithTriggering: true
              buildVersionToDownload: 'specific'
              buildId: '$(resources.pipeline.CIPublish.runID)'
              downloadType: 'single'
              artifactName: 'Configurations'
              downloadPath: '.'

          # Copy External Package Dependencies
          # use Node Tool
          - task: NodeTool@0
            displayName: 'Use Node ${{ variables.NodeVersion }}'
            inputs:
              versionSpec: ${{ variables.NodeVersion }}

          # Install cmf-pipeline
          - task: PowerShell@2
            displayName: 'Install cmf-pipeline@${{ variables.CmfPipelineVersion }}'
            inputs:
              pwsh: true
              failOnStderr: false
              workingDirectory: $(Agent.TempDirectory)
              targetType: inline
              script: |
                npm install --no-save @criticalmanufacturing/cmf-pipeline@${{ variables.CmfPipelineVersion }} --registry ${{ variables.CmfPipelineRepository }}

          - task: PowerShell@2
            displayName: "cmf-pipeline copyDependencies"
            inputs:
              targetType: 'inline'
              pwsh: true
              failOnStderr: false
              script: |
                $(Agent.TempDirectory)/node_modules/@criticalmanufacturing/cmf-pipeline/dist/win-x64/cmf-pipeline copyDependencies Configurations/dependencies.json ${{ variables.CandidatePackages }}/Package

          # Copy EnvironmentConfig to Server
          - task: CopyFiles@2
            displayName: 'Copy EnvironmentConfig to Server'
            inputs:
              SourceFolder: Configurations/EnvironmentConfigs
              Contents: '${{ variables.EnvironmentConfigName }}'
              TargetFolder: ${{ variables.CandidatePackages }}

          - task: PowerShell@2
            displayName: "Load configs and mount iso"
            inputs:
              targetType: 'inline'
              pwsh: true
              failOnStderr: false
              script: |
                # Assuming repository Checkout
                $EnvConfigFile = Get-Item "./Configurations/EnvironmentConfigs/${{ variables.EnvironmentConfigName }}"
                $EnvConfigJson = Get-Content -Raw -Path $EnvConfigFile | ConvertFrom-Json
                $ServerAddress = $EnvConfigJson.'Product.ApplicationServer.Address'
                Write-Output "##vso[task.setvariable variable=$("ServerAddress")]$ServerAddress"

                $CmfPackageJsonFile = Get-Item "./Configurations/cmfpackage.json"
                $CmfPackageJson = Get-Content -Raw -Path $CmfPackageJsonFile | ConvertFrom-Json
                $PackageId = $CmfPackageJson.'packageId'
                $PackageVersion = $CmfPackageJson.'version'
                $PackageToInstall = "$PackageId@$PackageVersion"
                Write-Output "##vso[task.setvariable variable=$("PackageToInstall")]$PackageToInstall"

                $sc =
                {
                  param ($ImagePath)

                    # Mount the ISO, without having a drive letter auto-assigned
                    if (!(Get-DiskImage -ImagePath $ImagePath).Attached) {
                        Mount-DiskImage -ImagePath $ImagePath -PassThru
                    }

                    $driveLetter = (Get-DiskImage -ImagePath $ImagePath | Get-Volume).DriveLetter + ':\'
                    Set-Location -Path $driveLetter

                    Write-Output "##vso[task.setvariable variable=$("DriveLetter")]$driveLetter"

                    if($LASTEXITCODE)
                    {
                        throw "Failed Mount-DiskImage"
                    }
                }

                try {
                  $iso = Get-Item "${{ variables.ISOImagePath }}"
                  $destPath = "${{ variables.CandidatePackages }}/../isos/"
                  $destIso = "$destPath/" + $iso.Name

                  if (-Not (Test-Path $destIso)) {
                      New-Item -Type Directory -Path $destPath -Force -Verbose
                      Copy-Item -Path $iso -Destination $destIso -Force -Verbose
                  }

                  Invoke-Command -ComputerName $ServerAddress -ScriptBlock $sc -ArgumentList @($destIso) | Out-Host
                }
                catch { throw (" *  Invoke-Command ERROR " + $_) }

          - task: PowerShell@2
            displayName: "Enable maintenance mode"
            condition: eq('${{ variables.UseMaintenanceMode }}', true)
            inputs:
              targetType: 'inline'
              pwsh: true
              failOnStderr: false
              script: |
                $sc =
                {
                  $parameters = "${{ variables.CandidatePackages }}\${{ variables.EnvironmentConfigName }}"
                  $maintenanceModePackageFolder = "$env:TEMP\Cmf";
                  $maintenanceModeDFRun = ".\tools\CmfDeploy.exe install --packageToInstall=Cmf.Configuration.MaintenanceMode@1.0.0 --parameters=$parameters --packageSource=$maintenanceModePackageFolder -logFileLocation ""${{ variables.CandidatePackages }}"""
                  $manifest =
                    ('<?xml version="1.0" encoding="utf-8"?>
                    <deploymentPackage>
                        <packageId>Cmf.Configuration.MaintenanceMode</packageId>
                        <name>Cmf SetMaintenanceMode</name>
                        <packageType>Generic</packageType>
                        <description>Cmf SetMaintenanceMode</description>
                        <version>1.0.0</version>
                        <isInstallable>True</isInstallable>
                        <isToForceInstall>True</isToForceInstall>
                        <steps>
                            <step type="UpdateConfiguration" configPath="/Cmf/System/Configuration/MaintenanceMode/IsEnabled/" value="True"/>
                        </steps>
                    </deploymentPackage>')

                    $manifestPath = "$maintenanceModePackageFolder\Cmf.Configuration.MaintenanceMode\manifest.xml"
                    New-Item -Type Directory -Path $maintenanceModePackageFolder -Force -Verbose
                    New-Item -Path $manifestPath -ItemType File -Value $manifest -Force -Verbose

                    Set-Location -Path $(DriveLetter)

                    # Enable MaintenanceMode
                    Write-Host("Script to run: " + $maintenanceModeDFRun)
                    Invoke-Expression $maintenanceModeDFRun | Out-Host
                    if($LASTEXITCODE)
                    {
                        throw "Installation Failed on Run MaintenanceMode ON"
                    }
                    Write-Host "MaintenanceMode ON"
                }

                try
                {
                  Invoke-Command -ComputerName $(ServerAddress) -ScriptBlock $sc | Out-Host
                }
                catch { throw (" *  Invoke-Command ERROR " + $_) }

          # Customization Installation
          - task: PowerShell@2
            displayName: "Customization Installation"
            inputs:
              targetType: 'inline'
              pwsh: true
              failOnStderr: false
              script: |
                $sc =
                {
                    $parameters = "${{ variables.CandidatePackages }}\${{ variables.EnvironmentConfigName }}"
                    Set-Location -Path $(DriveLetter)

                    $scriptPath = ".\tools\CmfDeploy.exe install --packageToInstall=$(PackageToInstall) --parameters=$parameters --packageSources=$(DriveLetter),""${{ variables.CandidatePackages }}"" -logFileLocation ""${{ variables.CandidatePackages }}"""
                    Write-Host("Script to run: " + $scriptPath)
                    Invoke-Expression $scriptPath | Out-Host
                    if($LASTEXITCODE)
                    {
                        throw "Installation Failed on Run CmfDeploy.exe install"
                    }
                }

                try
                {
                  Invoke-Command -ComputerName $(ServerAddress) -ScriptBlock $sc | Out-Host
                }
                catch { throw (" *  Invoke-Command ERROR " + $_) }

          - task: PowerShell@2
            displayName: "Disable maintenance mode"
            condition: eq('${{ variables.UseMaintenanceMode }}', true)
            inputs:
              targetType: 'inline'
              pwsh: true
              failOnStderr: false
              script: |
                $sc =
                {
                  $parameters = "${{ variables.CandidatePackages }}\${{ variables.EnvironmentConfigName }}"
                  $maintenanceModePackageFolder = "$env:TEMP\Cmf";
                  $maintenanceModeDFRun = ".\tools\CmfDeploy.exe install --packageToInstall=Cmf.Configuration.MaintenanceMode@1.0.0 --parameters=$parameters --packageSource=$maintenanceModePackageFolder -logFileLocation ""${{ variables.CandidatePackages }}"""
                  $manifest =
                    ('<?xml version="1.0" encoding="utf-8"?>
                    <deploymentPackage>
                        <packageId>Cmf.Configuration.MaintenanceMode</packageId>
                        <name>Cmf SetMaintenanceMode</name>
                        <packageType>Generic</packageType>
                        <description>Cmf SetMaintenanceMode</description>
                        <version>1.0.0</version>
                        <isInstallable>True</isInstallable>
                        <isToForceInstall>True</isToForceInstall>
                        <steps>
                            <step type="UpdateConfiguration" configPath="/Cmf/System/Configuration/MaintenanceMode/IsEnabled/" value="False"/>
                        </steps>
                    </deploymentPackage>')

                    $manifestPath = "$maintenanceModePackageFolder\Cmf.Configuration.MaintenanceMode\manifest.xml"
                    New-Item -Type Directory -Path $maintenanceModePackageFolder -Force -Verbose
                    New-Item -Path $manifestPath -ItemType File -Value $manifest -Force -Verbose

                    Set-Location -Path $(DriveLetter)

                    # Disable MaintenanceMode
                    Write-Host("Script to run: " + $maintenanceModeDFRun)
                    Invoke-Expression $maintenanceModeDFRun | Out-Host
                    if($LASTEXITCODE)
                    {
                        throw "Installation Failed on Run MaintenanceMode OFF"
                    }
                    Write-Host "MaintenanceMode OFF"
                }

                try
                {
                  Invoke-Command -ComputerName $(ServerAddress) -ScriptBlock $sc | Out-Host
                }
                catch { throw (" *  Invoke-Command ERROR " + $_) }

          # Clean
          - task: PostBuildCleanup@3
            displayName: "Clean Agent Directories"
            condition: always()

  - stage: "RestorePoint"
    displayName: "Restore Point"
    condition: or( and( eq('${{ parameters.executeAllStages }}', true), succeeded() ), and( eq('${{ parameters.executeAllStages }}', false), eq('${{ parameters.RestorePoint }}', true) ) )
    jobs:
      - job: "RestorePoint"
        displayName: "Restore Point"
        workspace:
          clean: all
        steps:
          - checkout: none

          # Download Configurations Artifacts
          - task: DownloadBuildArtifacts@0
            displayName: "Download Configurations Artifacts"
            inputs:
              buildType: 'specific'
              project: '<%= $CLI_PARAM_ProjectName %>'
              pipeline: 'CI-Publish'
              specificBuildWithTriggering: true
              buildVersionToDownload: 'specific'
              buildId: '$(resources.pipeline.CIPublish.runID)'
              downloadType: 'single'
              artifactName: 'Configurations'
              downloadPath: '.'

          # Get package version
          - task: PowerShell@2
            displayName: 'Get package version'
            inputs:
              targetType: inline
              script: |
                $CmfPackageJsonFile = Get-Item "./Configurations/cmfpackage.json"
                $CmfPackageJson = Get-Content -Raw -Path $CmfPackageJsonFile | ConvertFrom-Json
                $PackVersion = $CmfPackageJson.'version'
                $PackageId = $CmfPackageJson.'packageId'
                Write-Host "PackVersion = $PackVersion"
                Write-Host "PackageId = $PackageId"
                echo "##vso[task.setvariable variable=PackageVersion;isOutput=true]$PackVersion"
                echo "##vso[task.setvariable variable=PackageId;isOutput=true]$PackageId"
            name: GetPackageVersion

          # BackupRestoreTools Artifact
          - task: DownloadBuildArtifacts@0
            displayName: 'Download Build Artifacts - BackupRestore Tools'
            inputs:
              buildType: specific
              project: 'COMMON'
              pipeline: 'CI-BackupRestoreTools'
              specificBuildWithTriggering: true
              buildVersionToDownload: latestFromBranch
              branchName: '${{ variables.CommonBranch }}'
              downloadType: specific
              downloadPath: 'DownloadPackages'
              artifactName: Cmf.BackupRestore.Tools

          # Extract files - BackupRestoreTools
          - task: ExtractFiles@1
            displayName: "Extract files - BackupRestoreTools"
            inputs:
              archiveFilePatterns: "Cmf.BackupRestore.Tools.*.zip"
              destinationFolder: "BackupRestoreTools"
              cleanDestinationFolder: true
            continueOnError: false

          # Copy EnvironmentConfig to BackupRestoreTools
          - task: CopyFiles@2
            displayName: 'Copy EnvironmentConfig to BackupRestoreTools'
            inputs:
              SourceFolder: Configurations/EnvironmentConfigs
              Contents: '${{ variables.EnvironmentConfigName }}'
              TargetFolder: BackupRestoreTools/EnvironmentConfigs

          # Create Restore Point
          - task: PowerShell@2
            displayName: "Create Restore Point"
            inputs:
              pwsh: false
              targetType: filePath
              filePath: './BackupRestoreTools/DeploymentTools/SystemBackup.ps1'
              arguments: "-EnvironmentConfigName ${{ variables.EnvironmentConfigName }} -backupIdentifier $(GetPackageVersion.PackageId)_$(GetPackageVersion.PackageVersion) -InteractiveMode:$false"
            continueOnError: false

          # Clean
          - task: PostBuildCleanup@3
            displayName: "Clean Agent Directories"
            condition: always()

  - stage: "RunTestMasterData"
    displayName: "Run Test Master Data"
    condition: or( and( eq('${{ parameters.executeAllStages }}', true), succeeded() ), and( eq('${{ parameters.executeAllStages }}', false), eq('${{ parameters.RunTestMasterData }}', true) ) )
    jobs:
    - job: "RunTestMasterData"
      displayName: "Run Test Master Data"
      workspace:
        clean: all
      steps:
        - checkout: none

        # Download Configurations Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Configurations Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Configurations'
            downloadPath: '.'

        # Download Tests Artifacts
        - task: DownloadBuildArtifacts@0
          displayName: "Download Tests Artifacts"
          inputs:
            buildType: 'specific'
            project: '<%= $CLI_PARAM_ProjectName %>'
            pipeline: 'CI-Publish'
            specificBuildWithTriggering: true
            buildVersionToDownload: 'specific'
            buildId: '$(resources.pipeline.CIPublish.runID)'
            downloadType: 'single'
            artifactName: 'Tests'
            downloadPath: '${{ variables.CandidatePackages }}'
          continueOnError: true

        # Verify if Artifact exists - Tests.MasterData
        - task: PowerShell@2
          displayName: Verify if Artifact exists - Tests.MasterData
          inputs:
            targetType: inline
            script: |
                $masterDataFiles = "${{ variables.CandidatePackages }}/Tests/*MasterData*.zip"
                Write-Host "##vso[task.setVariable variable=ArtifactExists;]false"

                if (Get-ChildItem -Path $masterDataFiles)
                {
                    Write-Host "##vso[task.setVariable variable=ArtifactExists;]true"
                }

        # Copy EnvironmentConfig to Server
        - task: CopyFiles@2
          displayName: 'Copy ${{ variables.EnvironmentConfigName }} to ${{ variables.CandidatePackages }}'
          inputs:
            SourceFolder: Configurations/EnvironmentConfigs
            Contents: '${{ variables.EnvironmentConfigName }}'
            TargetFolder: ${{ variables.CandidatePackages }}
          condition: eq(variables['ArtifactExists'], true)

        # Load Master Data Files
        - task: PowerShell@2
          displayName: "Load Master Data Files"
          inputs:
            pwsh: false
            arguments: "-ImagePath '${{ variables.ISOImagePath }}' -EnvironmentConfigName '${{ variables.EnvironmentConfigName }}' -PackageSource '${{ variables.CandidatePackages }}'"
            targetType: 'inline'
            script: |
                $ImagePath = '${{ variables.ISOImagePath }}'; 
                $EnvironmentConfigName = '${{ variables.EnvironmentConfigName }}';
                $PackageSource = '${{ variables.CandidatePackages }}';

                # Assuming repository Checkout
                $EnvironmentConfig = "$EnvironmentConfigName";
                $EnvConfigFile = Get-Item "./Configurations/EnvironmentConfigs/$EnvironmentConfig"
                $EnvConfigJson = Get-Content -Raw -Path $EnvConfigFile | ConvertFrom-Json
                $ServerAddress = $EnvConfigJson.'Product.ApplicationServer.Address'

                $sc = {
                    param ($ImagePath, $PackageId, $PackageVersion, $PackageSource, $EnvironmentConfig)

                    $parameters = "$PackageSource\$EnvironmentConfig"
                    $package = "$PackageId@$PackageVersion"

                    # Mount the ISO, without having a drive letter auto-assigned
                    if (!(Get-DiskImage -ImagePath $ImagePath).Attached) {
                        Mount-DiskImage -ImagePath $ImagePath -PassThru  | Out-Null
                    }
                    $driveLetter = (Get-DiskImage -ImagePath $ImagePath | Get-Volume).DriveLetter
                    $PackageSource = $PackageSource #+ '\' + $PackageVersion
                    Set-Location -Path $driveLetter':\'
                    $scriptPath = '.\tools\CmfDeploy.exe install ' + $package + ' --parameters="' + $parameters + '" --packageSources="' + $driveLetter + ':\,' + $PackageSource + '" -logFileLocation "' + $PackageSource + '"'

                    Write-Host("Script to run: " + $scriptPath)

                    Invoke-Expression $scriptPath | Out-Host
                    if($LASTEXITCODE)
                    {
                        throw "Installation Failed!"
                    }
                }

                try {
                    $iso = Get-Item $ImagePath
                    $destPath = "${{ variables.CandidatePackages }}/../isos/"
                    $destIso = "$destPath/" + $iso.Name

                    if (-Not (Test-Path $destIso)) {
                        New-Item -Type Directory -Path $destPath -Force -Verbose
                        Copy-Item -Path $iso -Destination $destIso -Force -Verbose
                    }

                    $masterDataFiles = "${{ variables.CandidatePackages }}/Tests/*MasterData*.zip"

                    Get-ChildItem $masterDataFiles | foreach {
                        $PackageId = [regex]::split($_.BaseName, ".[0-9]+.[0-9]+.[0-9]+")[0];
                        $PackageVersion = ($_.BaseName-replace "$PackageId." );
                        Invoke-Command -ComputerName $ServerAddress -ScriptBlock $sc -ArgumentList @($destIso, $PackageId, $PackageVersion, $PackageSource, $EnvironmentConfig) | Out-Host
                    }

                    # Dismount ISO
                    $dismountSB = {
                      param ($ImagePath)
                      Dismount-DiskImage -ImagePath $ImagePath | Out-Null
                    }
                    Invoke-Command -ComputerName $ServerAddress -ScriptBlock $dismountSB -ArgumentList @($destIso) | Out-Host
                }
                catch {
                    throw (" *  Invoke-Command ERROR " + $_)
                }

        # Clean
        - task: PostBuildCleanup@3
          displayName: "Clean Agent Directories"
          condition: always()

  - stage: "DailyBackup"
    displayName: "Daily Backup"
    condition: or( and( eq('${{ parameters.executeAllStages }}', true), succeeded() ), and( eq('${{ parameters.executeAllStages }}', false), eq('${{ parameters.DailyBackup }}', true) ) )
    jobs:
      - job: "DailyBackup"
        displayName: "Daily Backup"
        workspace:
          clean: all
        steps:
          - checkout: none

          # Download Configurations Artifacts
          - task: DownloadBuildArtifacts@0
            displayName: "Download Configurations Artifacts"
            inputs:
              buildType: 'specific'
              project: '<%= $CLI_PARAM_ProjectName %>'
              pipeline: 'CI-Publish'
              specificBuildWithTriggering: true
              buildVersionToDownload: 'specific'
              buildId: '$(resources.pipeline.CIPublish.runID)'
              downloadType: 'single'
              artifactName: 'Configurations'
              downloadPath: '.'

          # BackupRestoreTools Artifact
          - task: DownloadBuildArtifacts@0
            displayName: 'Download Build Artifacts - BackupRestore Tools'
            inputs:
              buildType: specific
              project: 'COMMON'
              pipeline: 'CI-BackupRestoreTools'
              specificBuildWithTriggering: true
              buildVersionToDownload: latestFromBranch
              branchName: '${{ variables.CommonBranch }}'
              downloadType: specific
              downloadPath: 'DownloadPackages'
              artifactName: Cmf.BackupRestore.Tools

          # Extract files - BackupRestoreTools
          - task: ExtractFiles@1
            displayName: "Extract files - BackupRestoreTools"
            inputs:
              archiveFilePatterns: "Cmf.BackupRestore.Tools.*.zip"
              destinationFolder: "BackupRestoreTools"
              cleanDestinationFolder: true
            continueOnError: false

          # Copy EnvironmentConfig to BackupRestoreTools
          - task: CopyFiles@2
            displayName: 'Copy EnvironmentConfig to BackupRestoreTools'
            inputs:
              SourceFolder: Configurations/EnvironmentConfigs
              Contents: '${{ variables.EnvironmentConfigName }}'
              TargetFolder: BackupRestoreTools/EnvironmentConfigs

          # Create Restore Point - DailyBackup
          - task: PowerShell@2
            displayName: "Create Restore Point - DailyBackup"
            inputs:
              pwsh: false
              targetType: filePath
              filePath: './BackupRestoreTools/DeploymentTools/SystemBackup.ps1'
              arguments: "-EnvironmentConfigName ${{ variables.EnvironmentConfigName }} -backupIdentifier 'DailyBackup' -InteractiveMode:$false -FullBackup:$false -BackupDBOnline:$true -doNotStopHosts:$true"
            continueOnError: false

          # Clean
          - task: PostBuildCleanup@3
            displayName: "Clean Agent Directories"
            condition: always()

  - stage: "RunTests"
    displayName: "Run Tests"
    condition: or( and( eq('${{ parameters.executeAllStages }}', true), succeeded() ), and( eq('${{ parameters.executeAllStages }}', false), eq('${{ parameters.RunTests }}', true) ) )
    jobs:
      - job: "RunTests"
        timeoutInMinutes: 720 # 12 hours
        displayName: "Run Tests"
        workspace:
          clean: all
        steps:
          - checkout: none

          # Download Configurations Artifacts
          - task: DownloadBuildArtifacts@0
            displayName: "Download Configurations Artifacts"
            inputs:
              buildType: 'specific'
              project: '<%= $CLI_PARAM_ProjectName %>'
              pipeline: 'CI-Publish'
              specificBuildWithTriggering: true
              buildVersionToDownload: 'specific'
              buildId: '$(resources.pipeline.CIPublish.runID)'
              downloadType: 'single'
              artifactName: 'Configurations'
              downloadPath: '.'

          # Copy Copy global.json to root
          - task: CopyFiles@2
            displayName: 'Copy global.json to root'
            inputs:
              SourceFolder: Configurations
              Contents: 'global.json'
              TargetFolder: '.'

          # Download Tests Artifacts
          - task: DownloadBuildArtifacts@0
            displayName: "Download Tests Artifacts"
            inputs:
              buildType: 'specific'
              project: '<%= $CLI_PARAM_ProjectName %>'
              pipeline: 'CI-Publish'
              specificBuildWithTriggering: true
              buildVersionToDownload: 'specific'
              buildId: '$(resources.pipeline.CIPublish.runID)'
              downloadType: 'single'
              artifactName: 'Tests'
              downloadPath: '$(Build.SourcesDirectory)'
            continueOnError: true

          # Verify if Artifact exists - Tests
          - task: PowerShell@2
            displayName: Verify if Artifact exists - Tests
            inputs:
              targetType: inline
              script: |
                Write-Host "##vso[task.setVariable variable=ArtifactExists;]false"
                $artifactPath = "$(Build.SourcesDirectory)/Tests/*.zip"
                Write-Host "$artifactPath"
                if (Get-ChildItem -Path $artifactPath)
                {
                  ls $artifactPath
                  Get-ChildItem $artifactPath | foreach { 
                    $targetDirectory = "$(Build.SourcesDirectory)/TestExecution/" + $_.BaseName
                    Write-Host "$_ -> $targetDirectory"
                    Expand-Archive $_ -DestinationPath $targetDirectory -Force 
                  }
                  Write-Host "##vso[task.setVariable variable=ArtifactExists;]true"
                }
                else
                {
                  Write-Host "If fails"
                }
                Write-Host "$Env:ArtifactExists"

          # UseDotNet
          - task: UseDotNet@2
            displayName: 'Use Repository specified .NET Core version'
            inputs:
              packageType: 'sdk'
              useGlobalJson: true

          # Copy RunSettings to TestExecution
          - task: CopyFiles@2
            displayName: 'Copy RunSettings to TestExecution'
            inputs:
              SourceFolder: Configurations
              Contents: 'RunSettings/**'
              TargetFolder: 'TestExecution'

          # Run Tests - Business
          - task: VSTest@2
            displayName: "Run Tests - Business"
            inputs:
              testAssemblyVer2: '**\*.Biz.dll'
              searchFolder: $(System.DefaultWorkingDirectory)
              resultsFolder: '$(Agent.TempDirectory)\TestResults'
              runSettingsFile: 'TestExecution\RunSettings\${{ variables.RunSettings }}'
              testRunTitle: "Business Tests"
              rerunFailedTests: true
              rerunType: "basedOnTestFailurePercentage" # Optional. Options: basedOnTestFailurePercentage, basedOnTestFailureCount
              rerunFailedThreshold: "30"
              rerunMaxAttempts: "3"
            continueOnError: true
            condition: eq(variables['ArtifactExists'], true)

          # Run Tests - HTML
          - task: VSTest@2
            displayName: "Run Tests - HTML"
            inputs:
              testAssemblyVer2: '**\*.GUI.dll'
              searchFolder: $(System.DefaultWorkingDirectory)
              resultsFolder: '$(Agent.TempDirectory)\TestResults'
              runSettingsFile: 'TestExecution\RunSettings\${{ variables.RunSettings }}'
              testRunTitle: "HTML Tests"
              rerunFailedTests: true
              rerunType: "basedOnTestFailurePercentage" # Optional. Options: basedOnTestFailurePercentage, basedOnTestFailureCount
              rerunFailedThreshold: "30"
              rerunMaxAttempts: "3"
            continueOnError: true
            condition: eq(variables['ArtifactExists'], true)

          # Run Tests - IoT
          - task: VSTest@2
            displayName: "Run Tests - IoT"
            inputs:
              testAssemblyVer2: '**\*.IoT.dll'
              searchFolder: $(System.DefaultWorkingDirectory)
              resultsFolder: '$(Agent.TempDirectory)\TestResults'
              platform: latest
              runSettingsFile: 'TestExecution\RunSettings\${{ variables.RunSettings }}'
              testRunTitle: "IoT Tests"
              rerunFailedTests: true
              rerunType: "basedOnTestFailurePercentage" # Optional. Options: basedOnTestFailurePercentage, basedOnTestFailureCount
              rerunFailedThreshold: "30"
              rerunMaxAttempts: "3"
            continueOnError: true
            condition: eq(variables['ArtifactExists'], true)

          # Clean
          - task: PostBuildCleanup@3
            displayName: "Clean Agent Directories"
            condition: always()

  - stage: "ApprovalAndRetain"
    displayName: "Approval and Retain"
    condition: or( and( eq('${{ parameters.executeAllStages }}', true), succeeded() ), and( eq('${{ parameters.executeAllStages }}', false), eq('${{ parameters.ApprovalAndRetain }}', true) ) )
    jobs:
      - deployment:
        timeoutInMinutes: 2880 # 48 hours
        displayName: "Approval and Retain"
        workspace:
          clean: all
        environment: ${{ parameters.Environment }}
        cancelTimeoutInMinutes: 2880 # 48 hours
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: none

                # Download Configurations Artifacts
                - task: DownloadBuildArtifacts@0
                  displayName: "Download Configurations Artifacts"
                  inputs:
                    buildType: 'specific'
                    project: '<%= $CLI_PARAM_ProjectName %>'
                    pipeline: 'CI-Publish'
                    specificBuildWithTriggering: true
                    buildVersionToDownload: 'specific'
                    buildId: '$(resources.pipeline.CIPublish.runID)'
                    downloadType: 'single'
                    artifactName: 'Configurations'
                    downloadPath: '.'

                # Get package version
                - task: PowerShell@2
                  displayName: 'Get package version'
                  inputs:
                    targetType: inline
                    script: |
                      $CmfPackageJsonFile = Get-Item "./Configurations/cmfpackage.json"
                      $CmfPackageJson = Get-Content -Raw -Path $CmfPackageJsonFile | ConvertFrom-Json
                      $PackVersion = $CmfPackageJson.'version'
                      $PackageId = $CmfPackageJson.'packageId'
                      Write-Host "PackVersion = $PackVersion"
                      Write-Host "PackageId = $PackageId"
                      echo "##vso[task.setvariable variable=PackageVersion;isOutput=true]$PackVersion"
                      echo "##vso[task.setvariable variable=PackageId;isOutput=true]$PackageId"
                  name: GetPackageVersion

                # Get Date
                - task: PowerShell@2
                  displayName: "Get Date"
                  inputs:
                    pwsh: false
                    targetType: inline
                    script: |
                      $date=$(Get-Date -Format "yyyyMMdd");
                      Write-Host "##vso[task.setvariable variable=time]$date"
                  continueOnError: false

                # Tag Git Source
                - task: git-tag-on-release-task@9
                  displayName: "Tag Git Source"
                  inputs:
                    staticTagName: "<%= $CLI_PARAM_Tenant %>-$(time)-$(GetPackageVersion.PackageVersion)"

                # Retain indefinitely current release
                - task: retainPipeline@3
                  displayName: "Retain indefinitely current release"
                  inputs:
                    lock: true

                # Download Package Artifacts
                - task: DownloadBuildArtifacts@0
                  displayName: "Download Package Artifacts"
                  inputs:
                    buildType: 'specific'
                    project: '<%= $CLI_PARAM_ProjectName %>'
                    pipeline: 'CI-Publish'
                    specificBuildWithTriggering: true
                    buildVersionToDownload: 'specific'
                    buildId: '$(resources.pipeline.CIPublish.runID)'
                    downloadType: 'single'
                    artifactName: 'Package'
                    downloadPath: 'PackageApproved'

                # Copy generated Packages to Repository
                - task: CopyFiles@2
                  displayName: 'Copy generated Packages From Repository'
                  inputs:
                    SourceFolder: 'PackageApproved/Package'
                    Contents: |
                      *.zip
                    TargetFolder: '${{ variables.ApprovedPackages }}'
                    OverWrite: false

                # Download Tests Artifacts
                - task: DownloadBuildArtifacts@0
                  displayName: "Download Tests Artifacts"
                  inputs:
                    buildType: 'specific'
                    project: '<%= $CLI_PARAM_ProjectName %>'
                    pipeline: 'CI-Publish'
                    specificBuildWithTriggering: true
                    buildVersionToDownload: 'specific'
                    buildId: '$(resources.pipeline.CIPublish.runID)'
                    downloadType: 'single'
                    artifactName: 'Tests'
                    downloadPath: 'TestPackageApproved'

                # Copy generated Packages to Repository
                - task: CopyFiles@2
                  displayName: 'Copy generated Packages To Repository'
                  inputs:
                    SourceFolder: 'TestPackageApproved/Tests'
                    Contents: |
                      *.zip
                    TargetFolder: '${{ variables.ApprovedPackages }}'
                    OverWrite: false

                # Clean
                - task: PostBuildCleanup@3
                  displayName: "Clean Agent Directories"
                  condition: always()

  - stage: "RenameRestorePoint"
    displayName: "Rename RestorePoint to ORIGINAL"
    condition: or( and( eq('${{ variables.SetNewRestorePoint }}', true), eq('${{ parameters.executeAllStages }}', true), succeeded() ), and( eq('${{ parameters.executeAllStages }}', false), eq('${{ parameters.RenameRestorePoint }}', true) ) )
    jobs:
      - job: "RenameRestorePoint"
        displayName: "Rename RestorePoint to ORIGINAL"
        workspace:
          clean: all
        steps:
          - checkout: none

          # Download Configurations Artifacts
          - task: DownloadBuildArtifacts@0
            displayName: "Download Configurations Artifacts"
            inputs:
              buildType: 'specific'
              project: '<%= $CLI_PARAM_ProjectName %>'
              pipeline: 'CI-Publish'
              specificBuildWithTriggering: true
              buildVersionToDownload: 'specific'
              buildId: '$(resources.pipeline.CIPublish.runID)'
              downloadType: 'single'
              artifactName: 'Configurations'
              downloadPath: '.'

          # Get package version
          - task: PowerShell@2
            displayName: 'Get package version'
            inputs:
              targetType: inline
              script: |
                $CmfPackageJsonFile = Get-Item "./Configurations/cmfpackage.json"
                $CmfPackageJson = Get-Content -Raw -Path $CmfPackageJsonFile | ConvertFrom-Json
                $PackVersion = $CmfPackageJson.'version'
                $PackageId = $CmfPackageJson.'packageId'
                Write-Host "PackVersion = $PackVersion"
                Write-Host "PackageId = $PackageId"
                echo "##vso[task.setvariable variable=PackageVersion;isOutput=true]$PackVersion"
                echo "##vso[task.setvariable variable=PackageId;isOutput=true]$PackageId"
            name: GetPackageVersion

          # Rename RestorePoint to ORIGINAL
          - task: PowerShell@2
            displayName: "Rename RestorePoint to ORIGINAL"
            inputs:
              pwsh: false
              targetType: inline
              failOnStderr: true
              script: |
                $EnvironmentConfig = "${{ variables.EnvironmentConfigName }}";
                $EnvConfigFile = Get-Item "./Configurations/EnvironmentConfigs/$EnvironmentConfig"
                $EnvConfigJson = Get-Content -Raw -Path $EnvConfigFile | ConvertFrom-Json
                $BackupLocation = $EnvConfigJson.'Product.Database.BackupShare'

                Set-Location $BackupLocation -Verbose

                $originalKeyword = "$(RestoreIdentifier)"
                $restorePointKeyword = "$(GetPackageVersion.PackageId)_$(GetPackageVersion.PackageVersion)"
                $date = (Get-Date).ToString("yyyyMMdd")
                $oldRestorePointName = "Before-<%= $CLI_PARAM_Tenant %>-$date-$(GetPackageVersion.PackageVersion)"

                $originalFolderSearch = (Get-ChildItem -Filter $originalKeyword -Directory)
                $restorePointFolder =  (Get-ChildItem -Filter $restorePointKeyword -Directory)[0]

                # Rename Original Folder if exists
                if ($originalFolderSearch)
                {
                  $originalFolder =  (Get-ChildItem -Filter $originalKeyword -Directory)[0]
                  Rename-Item -Path $originalFolder -NewName $oldRestorePointName -Verbose -Force
                  Set-Location $oldRestorePointName -Verbose
                  $oldRestorePointFiles = Get-ChildItem -Filter "*$originalKeyword*" -File -Verbose
                  foreach ($oldRestorePointFile in $oldRestorePointFiles) {
                      Rename-Item -Path $oldRestorePointFile -NewName ($oldRestorePointFile.Name -replace $originalKeyword, $oldRestorePointName) -Verbose
                  }

                  Set-Location $BackupLocation -Verbose
                }

                Copy-Item -Path $restorePointFolder $originalKeyword -Verbose -Force -Recurse

                $originalFolder =  (Get-ChildItem -Filter $originalKeyword -Directory)[0]
                Set-Location $originalFolder -Verbose
                $restorePointFiles = Get-ChildItem -Filter "*$restorePointKeyword*" -File -Verbose
                foreach ($restorePointFile in $restorePointFiles) {
                    Rename-Item -Path $restorePointFile -NewName ($restorePointFile.Name -replace $restorePointKeyword, $originalKeyword) -Verbose -Force
                }

                Set-Location $BackupLocation -Verbose
            continueOnError: false

          # Clean
          - task: PostBuildCleanup@3
            displayName: "Clean Agent Directories"
            condition: always()